# Overwritten in meta.R
meta_call_start <- function(...) {}
meta_call_end <- function(...) {}
meta_ext_register <- function(...) {}
meta_rel_register <- function(...) {}
meta_rel_register_df <- function(...) {}
meta_rel_register_file <- function(...) {}
meta_rel_get <- function(...) {}
meta_macro_register <- function(...) {}

# Generated by 02-duckplyr_df-methods.R
#' @export
add_count.data.frame <- function(x, ..., wt = NULL, sort = FALSE, name = NULL, .drop = deprecated()) {
  # Our implementation
  rel_try(NULL,
    "No relational implementation for add_count()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  add_count <- add_count_data_frame
  out <- add_count(x, ..., wt = {{ wt }}, sort = sort, name = name, .drop = .drop)
  return(out)

  # dplyr implementation
  out <- add_count_impl(
    x,
    ...,
    wt = {{ wt }},
    sort = sort,
    name = name,
    .drop = .drop
  )
  dplyr_reconstruct(out, x)
}

duckplyr_add_count <- function(x, ...) {
  try_fetch(
    x <- as_duckplyr_df(x),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- add_count(x, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
anti_join.data.frame <- function(x, y, by = NULL, copy = FALSE, ..., na_matches = c("na", "never")) {
  check_dots_empty0(...)
  error_call <- caller_env()
  y <- auto_copy(x, y, copy = copy)

  # https://github.com/duckdb/duckdb/issues/6597
  na_matches <- check_na_matches(na_matches, error_call = error_call)

  # Our implementation
  rel_try(list(name = "anti_join", x = x, y = y, args = list(by = if (!is.null(by) && !is_cross_by(by)) as_join_by(by), copy = copy, na_matches = na_matches)),
    "No restrictions" = FALSE,
    {
      out <- rel_join_impl(x, y, by, "anti", na_matches, error_call = error_call)
      return(out)
    }
  )

  # dplyr forward
  anti_join <- anti_join_data_frame
  out <- anti_join(x, y, by, copy = FALSE, ..., na_matches = na_matches)
  return(out)

  # dplyr implementation
  check_dots_empty0(...)
  y <- auto_copy(x, y, copy = copy)
  join_filter(x, y, by = by, type = "anti", na_matches = na_matches, user_env = caller_env())
}

duckplyr_anti_join <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- anti_join(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
arrange.data.frame <- function(.data, ..., .by_group = FALSE, .locale = NULL) {
  force(.data)

  dots <- enquos(...)
  dots <- unname(dots)

  rel_try(list(name = "arrange", x = .data, args = list(dots = dots, .by_group = .by_group)),
    ".by_group = TRUE not supported" = !identical(.by_group, FALSE),
    ".locale argument not supported" = !is.null(.locale),
    "dplyr.legacy_locale not supported" = isTRUE(getOption("dplyr.legacy_locale")),
    {
      # Translate to df before early exit, so that we can bail out for subclasses
      rel <- duckdb_rel_from_df(.data)
      if (length(dots) == 0) {
        return(.data)
      }

      dots_ascending <- handle_desc(dots)
      dots <- dots_ascending$dots
      ascending <- dots_ascending$ascending

      exprs <- rel_translate_dots(dots, .data)

      if (oo_force()) {
        rel <- oo_prep(rel, force = TRUE)
        exprs <- c(exprs, list(relexpr_reference("___row_number")))
        ascending <- c(ascending, TRUE)
      }

      rel <- rel_order(rel, exprs, ascending)

      # Don't need to sort here, already sorting by ___row_number
      if (oo_force()) {
        out_rel <- oo_restore_cols(rel)
      } else {
        out_rel <- rel
      }

      out <- rel_to_df(out_rel)
      out <- dplyr_reconstruct(out, .data)
      return(out)
    }
  )

  # dplyr forward
  arrange <- arrange_data_frame
  out <- arrange(.data, ..., .by_group = .by_group, .locale = .locale)
  return(out)

  # dplyr implementation
  dots <- enquos(...)

  if (.by_group) {
    dots <- c(quos(!!!groups(.data)), dots)
  }

  loc <- arrange_rows(.data, dots = dots, locale = .locale)
  dplyr_row_slice(.data, loc)
}

duckplyr_arrange <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- arrange(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

#' Convert to a duckplyr data frame
#'
#' @description
#' These functions convert a data-frame-like input to an object of class `"duckpylr_df"`.
#' For such objects,
#' dplyr verbs such as [mutate()], [select()] or [filter()]  will attempt to use DuckDB.
#' If this is not possible, the original dplyr implementation is used.
#'
#' `as_duckplyr_df()` requires the input to be a plain data frame or a tibble,
#' and will fail for any other classes, including subclasses of `"data.frame"` or `"tbl_df"`.
#' This behavior is likely to change, do not rely on it.
#'
#' @details
#' Set the `DUCKPLYR_FALLBACK_INFO` and `DUCKPLYR_FORCE` environment variables
#' for more control over the behavior, see [config] for more details.
#'
#' @param .data data frame or tibble to transform
#'
#' @return For `as_duckplyr_df()`, an object of class `"duckplyr_df"`,
#'   inheriting from the classes of the `.data` argument.
#'
#' @export
#' @examples
#' tibble(a = 1:3) %>%
#'   mutate(b = a + 1)
#'
#' tibble(a = 1:3) %>%
#'   as_duckplyr_df() %>%
#'   mutate(b = a + 1)
as_duckplyr_df <- function(.data) {
  if (inherits(.data, "duckplyr_df")) {
    return(.data)
  }

  if (!identical(class(.data), "data.frame") && !identical(class(.data), c("tbl_df", "tbl", "data.frame"))) {
    cli::cli_abort("Must pass a plain data frame or a tibble to `as_duckplyr_df()`.")
  }

  if (anyNA(names(.data)) || any(names(.data) == "")) {
    cli::cli_abort("Missing or empty names not allowed.")
  }

  class(.data) <- c("duckplyr_df", class(.data))
  .data
}

#' as_duckplyr_tibble
#'
#' `as_duckplyr_tibble()` converts the input to a tibble and then to a duckplyr data frame.
#'
#' @return For `as_duckplyr_tibble()`, an object of class
#'   `c("duckplyr_df", class(tibble()))` .
#'
#' @rdname as_duckplyr_df
#' @export
as_duckplyr_tibble <- function(.data) {
  if (inherits(.data, "tbl_duckdb_connection")) {
    con <- dbplyr::remote_con(.data)
    sql <- dbplyr::remote_query(.data)
    rel <- duckdb$rel_from_sql(con, sql)
    out <- rel_to_df(rel)
    class(out) <- c("duckplyr_df", class(new_tibble(list())))
    return(out)
  }

  # Extra as.data.frame() call for good measure and perhaps https://github.com/tidyverse/tibble/issues/1556
  as_duckplyr_df(as_tibble(as.data.frame(.data)))
}

# Generated by 02-duckplyr_df-methods.R
#' @export
auto_copy.data.frame <- function(x, y, copy = FALSE, ...) {
  return(as_duckplyr_df(as.data.frame(y)))

  # dplyr implementation
  as.data.frame(y)
}

duckplyr_auto_copy <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- auto_copy(x, y, ...)
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
collect.data.frame <- function(x, ...) {
  # Side effect: ALTREP materialization is triggered
  nrow(x)
  x
}

duckplyr_collect <- function(x, ...) {
  try_fetch(
    x <- as_duckplyr_df(x),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- collect(x, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
compute.data.frame <- function(x, ...) {
  # Our implementation
  rel_try(NULL,
    "No relational implementation for compute()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  compute <- compute_data_frame
  out <- compute(x, ...)
  return(out)

  # dplyr implementation
  x
}

duckplyr_compute <- function(x, ...) {
  try_fetch(
    x <- as_duckplyr_df(x),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- compute(x, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

#' Configuration options
#'
#' The behavior of duckplyr can be fine-tuned with several environment variables,
#' and one option.
#'
#' @section Options:
#'
#' `duckdb.materialize_message`: Set to `FALSE` to turn off diagnostic output from duckdb
#' on data frame materialization.
#' Currenty set to `TRUE` when duckplyr is loaded.
#'
#' @section Environment variables:
#'
#' `DUCKPLYR_OUTPUT_ORDER`: If `TRUE`, row output order is preserved.
#' The default may change the row order where dplyr would keep it stable.
#'
#' `DUCKPLYR_FORCE`: If `TRUE`, fail if duckdb cannot handle a request.
#'
#' `DUCKPLYR_FALLBACK_INFO`: If `TRUE`, print a message when a fallback to dplyr occurs
#' because duckdb cannot handle a request.
#'
#' `DUCKPLYR_CHECK_ROUNDTRIP`: If `TRUE`, check if all columns are roundtripped perfectly
#' when creating a relational object from a data frame,
#' This is slow, and mostly useful for debugging.
#' The default is to check roundtrip of attributes.
#'
#' `DUCKPLYR_EXPERIMENTAL`: If `TRUE`, pass `experimental = TRUE`
#' to certain duckdb functions.
#' Currently unused.
#'
#' `DUCKPLYR_METHODS_OVERWRITE`: If `TRUE`, call `methods_overwrite()`
#' when the package is loaded.
#'
#' See [fallback] for more options related to logging and uploading of fallback events.
#'
# Not available in the CRAN package:
# `DUCKPLYR_META_GLOBAL`: Assume data frames in the global environment as "known".
# `DUCKPLYR_META_SKIP`: Skip recording the operations, replay not available.
#' @name config
#' @examples
#' # options(duckdb.materialize_message = FALSE)
#' data.frame(a = 3:1) %>%
#'   as_duckplyr_df() %>%
#'   inner_join(data.frame(a = 1:4), by = "a")
#'
#' rlang::with_options(duckdb.materialize_message = FALSE, {
#'   data.frame(a = 3:1) %>%
#'     as_duckplyr_df() %>%
#'     inner_join(data.frame(a = 1:4), by = "a") %>%
#'     print()
#' })
#'
#' # Sys.setenv(DUCKPLYR_OUTPUT_ORDER = TRUE)
#' data.frame(a = 3:1) %>%
#'   as_duckplyr_df() %>%
#'   inner_join(data.frame(a = 1:4), by = "a")
#'
#' withr::with_envvar(c(DUCKPLYR_OUTPUT_ORDER = "TRUE"), {
#'   data.frame(a = 3:1) %>%
#'     as_duckplyr_df() %>%
#'     inner_join(data.frame(a = 1:4), by = "a")
#' })
#'
#' # Sys.setenv(DUCKPLYR_FORCE = TRUE)
#' add_one <- function(x) {
#'   x + 1
#' }
#'
#' data.frame(a = 3:1) %>%
#'   as_duckplyr_df() %>%
#'   mutate(b = add_one(a))
#'
#' try(withr::with_envvar(c(DUCKPLYR_FORCE = "TRUE"), {
#'   data.frame(a = 3:1) %>%
#'     as_duckplyr_df() %>%
#'     mutate(b = add_one(a))
#' }))
#'
#' # Sys.setenv(DUCKPLYR_FALLBACK_INFO = TRUE)
#' withr::with_envvar(c(DUCKPLYR_FALLBACK_INFO = "TRUE"), {
#'   data.frame(a = 3:1) %>%
#'     as_duckplyr_df() %>%
#'     mutate(b = add_one(a))
#' })
NULL

#' Constructive options for class 'relational_relexpr_constant'
#'
#' These options will be used on objects of class 'relational_relexpr_constant'.
#'
#' Depending on `constructor`, we construct the object as follows:
#' * `"relexpr_constant"` (default): We build the object using `relexpr_constant()`.
#' * `"next"` : Use the constructor for the next supported class.
#'
#' @param constructor String. Name of the function used to construct the object.
#' @param ... Additional options used by user defined constructors through the `opts` object
#' @return An object of class <constructive_options/constructive_options_relational_relexpr_constant>
#' @noRd
opts_relational_relexpr_constant <- function(constructor = c("relexpr_constant", "next"), ...) {
  constructive::.cstr_options("relational_relexpr_constant", constructor = constructor[[1]], ...)
}

.cstr_construct.relational_relexpr_constant <- function(x, ...) {
  opts <- list(...)$opts$relational_relexpr_constant %||% opts_relational_relexpr_constant()
  if (is_corrupted_relational_relexpr_constant(x) || opts$constructor == "next") {
    return(NextMethod())
  }
  UseMethod(".cstr_construct.relational_relexpr_constant", structure(NA, class = opts$constructor))
}

is_corrupted_relational_relexpr_constant <- function(x) {
  FALSE
}

#' @export
#' @method .cstr_construct.relational_relexpr_constant relexpr_constant
.cstr_construct.relational_relexpr_constant.relexpr_constant <- function(x, ...) {
  # opts <- list(...)$opts$relational_relexpr_constant %||% opts_relational_relexpr_constant()
  args <- compact(list(
    x$val,
    alias = x$alias
  ))
  code <- constructive::.cstr_apply(args, fun = "relexpr_constant", ...)
  constructive::.cstr_repair_attributes(
    x, code, ...,
    idiomatic_class = c("relational_relexpr_constant", "relational_relexpr")
  )
}

on_load({
  vctrs::s3_register("constructive::.cstr_construct", "relational_relexpr_constant")
})

#' Constructive options for class 'relational_relexpr_function'
#'
#' These options will be used on objects of class 'relational_relexpr_function'.
#'
#' Depending on `constructor`, we construct the object as follows:
#' * `"relexpr_function"` (default): We build the object using `relexpr_function()`.
#' * `"next"` : Use the constructor for the next supported class.
#'
#' @param constructor String. Name of the function used to construct the object.
#' @param ... Additional options used by user defined constructors through the `opts` object
#' @return An object of class <constructive_options/constructive_options_relational_relexpr_function>
#' @noRd
opts_relational_relexpr_function <- function(constructor = c("relexpr_function", "next"), ...) {
  # What's forwarded through `...`will be accessible through the `opts`
  # object in the methods.
  # You might add arguments to the function, to document those options,
  # don't forget to forward them below as well
  constructive::.cstr_options("relational_relexpr_function", constructor = constructor[[1]], ...)
}

.cstr_construct.relational_relexpr_function <- function(x, ...) {
  # There is probably no need for you to modify this function at all
  opts <- list(...)$opts$relational_relexpr_function %||% opts_relational_relexpr_function()
  if (is_corrupted_relational_relexpr_function(x) || opts$constructor == "next") {
    return(NextMethod())
  }
  # This odd looking code dispatches to a method based on the name of
  # the constructor rather than the class
  UseMethod(".cstr_construct.relational_relexpr_function", structure(NA, class = opts$constructor))
}

is_corrupted_relational_relexpr_function <- function(x) {
  # check here if the object has the right structure to be constructed
  # leaving FALSE is fine but you'll be vulnerable to corrupted objects
  FALSE
}

#' @export
#' @method .cstr_construct.relational_relexpr_function relexpr_function
.cstr_construct.relational_relexpr_function.relexpr_function <- function(x, ...) {
  # If needed, fetch additional options fed through opts_relational_relexpr_function()
  # opts <- list(...)$opts$relational_relexpr_function %||% opts_relational_relexpr_function()

  # Instead of the call below we need to fetch the args of the constructor in `x`.
  args <- Filter(function(.x) !is.null(.x), list(
    x$name,
    x$args,
    alias = x$alias
  ))

  # This creates a call relexpr_function(...) where ... is the constructed code
  # of the arguments stored in `args`
  # Sometimes we want to construct the code of the args separately, i.e. store
  # code rather than objects in `args`, and use `recurse = FALSE` below
  code <- constructive::.cstr_apply(args, fun = "relexpr_function", ...)

  # constructive::.cstr_repair_attributes() makes sure that attributes that are not built
  # by the idiomatic constructor are generated
  constructive::.cstr_repair_attributes(
    x, code, ...,
    # attributes built by the constructor
    # ignore =,

    # not necessarily just a string, but the whole class(x) vector
    idiomatic_class = c("relational_relexpr_function", "relational_relexpr")
  )
}

on_load({
  vctrs::s3_register("constructive::.cstr_construct", "relational_relexpr_function")
})

#' Constructive options for class 'relational_relexpr_reference'
#'
#' These options will be used on objects of class 'relational_relexpr_reference'.
#'
#' Depending on `constructor`, we construct the object as follows:
#' * `"relexpr_reference"` (default): We build the object using `relexpr_reference()`.
#' * `"next"` : Use the constructor for the next supported class.
#'
#' @param constructor String. Name of the function used to construct the object.
#' @param ... Additional options used by user defined constructors through the `opts` object
#' @return An object of class <constructive_options/constructive_options_relational_relexpr_reference>
#' @noRd
opts_relational_relexpr_reference <- function(constructor = c("relexpr_reference", "next"), ...) {
  constructive::.cstr_options("relational_relexpr_reference", constructor = constructor[[1]], ...)
}

.cstr_construct.relational_relexpr_reference <- function(x, ...) {
  opts <- list(...)$opts$relational_relexpr_reference %||% opts_relational_relexpr_reference()
  if (is_corrupted_relational_relexpr_reference(x) || opts$constructor == "next") {
    return(NextMethod())
  }
  UseMethod(".cstr_construct.relational_relexpr_reference", structure(NA, class = opts$constructor))
}

is_corrupted_relational_relexpr_reference <- function(x) {
  FALSE
}

#' @export
#' @method .cstr_construct.relational_relexpr_reference relexpr_reference
.cstr_construct.relational_relexpr_reference.relexpr_reference <- function(x, ...) {
  # opts <- list(...)$opts$relational_relexpr_reference %||% opts_relational_relexpr_reference()
  args <- compact(list(
    x$name,
    rel = x$rel,
    alias = x$alias
  ))
  code <- constructive::.cstr_apply(args, fun = "relexpr_reference", ...)
  constructive::.cstr_repair_attributes(
    x, code, ...,
    idiomatic_class = c("relational_relexpr_reference", "relational_relexpr")
  )
}

on_load({
  vctrs::s3_register("constructive::.cstr_construct", "relational_relexpr_reference")
})

#' Constructive options for class 'relational_relexpr_window'
#'
#' These options will be used on objects of class 'relational_relexpr_window'.
#'
#' Depending on `constructor`, we construct the object as follows:
#' * `"relexpr_window"` (default): We build the object using `relexpr_window()`.
#' * `"next"` : Use the constructor for the next supported class.
#'
#' @param constructor String. Name of the function used to construct the object.
#' @param ... Additional options used by user defined constructors through the `opts` object
#' @return An object of class <constructive_options/constructive_options_relational_relexpr_window>
#' @noRd
opts_relational_relexpr_window <- function(constructor = c("relexpr_window", "next"), ...) {
  constructive::.cstr_options("relational_relexpr_window", constructor = constructor[[1]], ...)
}

.cstr_construct.relational_relexpr_window <- function(x, ...) {
  opts <- list(...)$opts$relational_relexpr_window %||% opts_relational_relexpr_window()
  if (is_corrupted_relational_relexpr_window(x) || opts$constructor == "next") {
    return(NextMethod())
  }
  UseMethod(".cstr_construct.relational_relexpr_window", structure(NA, class = opts$constructor))
}

is_corrupted_relational_relexpr_window <- function(x) {
  FALSE
}

#' @export
#' @method .cstr_construct.relational_relexpr_window relexpr_window
.cstr_construct.relational_relexpr_window.relexpr_window <- function(x, ...) {
  # opts <- list(...)$opts$relational_relexpr_window %||% opts_relational_relexpr_window()
  args <- Filter(function(.x) !is.null(.x), list(
    x$expr,
    x$partitions,
    order_bys = if (length(x$order_bys) > 0) x$order_bys,
    offset_expr = x$offset_expr,
    default_expr = x$default_expr,
    alias = x$alias
  ))
  code <- constructive::.cstr_apply(args, fun = "relexpr_window", ...)
  constructive::.cstr_repair_attributes(
    x, code, ...,
    idiomatic_class = c("relational_relexpr_window", "relational_relexpr")
  )
}

on_load({
  vctrs::s3_register("constructive::.cstr_construct", "relational_relexpr_window")
})

# Generated by 02-duckplyr_df-methods.R
#' @export
count.data.frame <- function(x, ..., wt = NULL, sort = FALSE, name = NULL, .drop = group_by_drop_default(x)) {
  force(x)

  dplyr_local_error_call()

  by <- dplyr_quosures(...)
  by <- fix_auto_name(by)

  by_exprs <- unname(map(by, quo_get_expr))
  is_name <- map_lgl(by_exprs, is_symbol)

  # For better error message
  if (!is.null(name)) {
    check_string(name, call = dplyr_error_call())
  }

  # Passing `name` reliably is surprisingly complicated.
  rel_try(list(name = "count", x = x, args = list(dots = enquos(...), wt = enquo(wt), sort = sort, .drop = .drop)),
    "count() needs all(is_name)" = !all(is_name),
    "count() only implemented for .drop = TRUE" = !.drop,
    "count() only implemented for sort = FALSE" = sort,
    {
      rel <- duckdb_rel_from_df(x)

      by_chr <- map_chr(by_exprs, as_string)
      name_was_null <- is.null(name)
      name <- check_n_name(name, by_chr, call = dplyr_error_call())

      if (name %in% by_chr) {
        cli::cli_abort("Name clash in `count()`")
      }
      n <- tally_n(x, {{ wt }})

      groups <- rel_translate_dots(by, x)
      aggregates <- list(rel_translate(n, x, alias = name))

      out_rel <- rel_aggregate(rel, groups, unname(aggregates))
      if (length(groups) > 0) {
        sort_cols <- nexprs(names(groups))
        out_rel <- rel_order(out_rel, sort_cols)
      }

      out <- rel_to_df(out_rel)
      out <- dplyr_reconstruct(out, x)

      return(out)
    }
  )

  # FIXME: optimize, no need to forward dots
  # out <- count(x_df, !!!quos, wt = {{ wt }}, sort = sort, name = name, .drop = .drop)

  # dplyr forward
  count <- count_data_frame
  out <- count(x, ..., wt = {{ wt }}, sort = sort, name = name, .drop = .drop)
  return(out)

  # dplyr implementation
  dplyr_local_error_call()

  if (!missing(...)) {
    out <- group_by(x, ..., .add = TRUE, .drop = .drop)
  } else {
    out <- x
  }

  out <- tally(out, wt = !!enquo(wt), sort = sort, name = name)

  # Ensure grouping is transient
  out <- dplyr_reconstruct(out, x)

  out
}

duckplyr_count <- function(x, ...) {
  try_fetch(
    x <- as_duckplyr_df(x),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- count(x, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
cross_join.data.frame <- function(x, y, ..., copy = FALSE, suffix = c(".x", ".y")) {
  # Our implementation
  rel_try(NULL,
    "No relational implementation for cross_join()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  cross_join <- cross_join_data_frame
  out <- cross_join(x, y, ..., copy = copy, suffix = suffix)
  return(out)

  # dplyr implementation
  check_dots_empty0(...)

  y <- auto_copy(x, y, copy = copy)

  x_names <- tbl_vars(x)
  y_names <- tbl_vars(y)

  # Empty join by with no keys
  by <- new_join_by()

  # Particular value isn't too important, as there are no keys to keep/drop
  keep <- FALSE

  vars <- join_cols(
    x_names = x_names,
    y_names = y_names,
    by = by,
    suffix = suffix,
    keep = keep
  )

  x_in <- as_tibble(x, .name_repair = "minimal")
  y_in <- as_tibble(y, .name_repair = "minimal")

  x_size <- vec_size(x_in)
  y_size <- vec_size(y_in)

  x_out <- set_names(x_in, names(vars$x$out))
  y_out <- set_names(y_in, names(vars$y$out))

  x_out <- vec_rep_each(x_out, times = y_size)
  y_out <- vec_rep(y_out, times = x_size)

  x_out[names(y_out)] <- y_out

  dplyr_reconstruct(x_out, x)
}

duckplyr_cross_join <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- cross_join(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
utils::globalVariables("___row_number_by")

#' @export
distinct.data.frame <- function(.data, ..., .keep_all = FALSE) {
  dots <- enquos(..., .named = TRUE)

  # Our implementation
  rel_try(list(name = "distinct", x = .data, args = list(dots = dots, .keep_all = .keep_all)),
    "Implemented for all cases?" = FALSE,
    {
      # FIXME: avoid column duplication in a cleaner way
      dupes <- duplicated(names(dots), fromLast = TRUE)
      dots <- dots[!dupes]

      rel <- duckdb_rel_from_df(.data)

      oo <- .keep_all || oo_force()

      if (oo) {
        # Push row number as separate projection
        rel <- oo_prep(rel, force = TRUE)

        exprs <- rel_translate_dots(dots, .data)
        all_exprs <- NULL
        if (length(exprs) == 0) {
          exprs <- imap(set_names(names(.data)), relexpr_reference, rel = NULL)
          all_exprs <- exprs
        }

        if (.keep_all) {
          proj_exprs <- all_exprs %||% imap(set_names(names(.data)), relexpr_reference, rel = NULL)
        } else {
          proj_exprs <- exprs
        }

        proj_exprs <- c(proj_exprs, list(
          relexpr_reference("___row_number"),
          relexpr_window(
            relexpr_function("row_number", list()),
            partitions = exprs,
            order_bys = list(relexpr_reference("___row_number")),
            alias = "___row_number_by"
          )
        ))

        rel <- rel_project(rel, unname(proj_exprs))

        expr_filter <- rel_translate(
          quo(`___row_number_by` == 1L),
          names_data = "___row_number_by"
        )
        out_rel <- rel_filter(rel, list(expr_filter))

        out_rel <- oo_restore_order(out_rel, force = TRUE)
        out_rel <- oo_restore_cols(out_rel, extra = "___row_number_by", force = TRUE)
      } else {
        exprs <- rel_translate_dots(dots, .data)
        if (length(exprs) > 0) {
          rel <- rel_project(rel, exprs)
        }
        out_rel <- rel_distinct(rel)
      }

      out <- rel_to_df(out_rel)
      out <- dplyr_reconstruct(out, .data)
      return(out)
    }
  )

  # dplyr forward
  distinct <- distinct_data_frame
  out <- distinct(.data, ..., .keep_all = .keep_all)
  return(out)

  # dplyr implementation
  prep <- distinct_prepare(
    .data,
    vars = enquos(...),
    group_vars = group_vars(.data),
    .keep_all = .keep_all,
    caller_env = caller_env()
  )

  out <- prep$data

  cols <- dplyr_col_select(out, prep$vars)
  loc <- vec_unique_loc(cols)

  out <- dplyr_col_select(out, prep$keep)
  dplyr_row_slice(out, loc)
}

duckplyr_distinct <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- distinct(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
do.data.frame <- function(.data, ...) {
  # Our implementation
  rel_try(NULL,
    "No relational implementation for do()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  do <- do_data_frame
  out <- do(.data, ...)
  return(out)

  # dplyr implementation
  args <- enquos(...)
  named <- named_args(args)

  # Create custom data mask with `.` pronoun
  mask <- new_data_mask(new_environment())
  env_bind_do_pronouns(mask, .data)

  if (!named) {
    out <- eval_tidy(args[[1]], mask)
    if (!inherits(out, "data.frame")) {
      msg <- glue("Result must be a data frame, not {fmt_classes(out)}.")
      abort(msg)
    }
  } else {
    out <- map(args, function(arg) list(eval_tidy(arg, mask)))
    names(out) <- names(args)
    out <- tibble::as_tibble(out, .name_repair = "minimal")
  }

  out
}

duckplyr_do <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- do(.data, ...)
  out
}

fix_auto_name <- function(dots) {
  if (is.null(names(dots))) {
    dots <- set_names(dots, "")
  }

  for (i in seq_along(dots)) {
    dot <- dots[[i]]
    if (names(dots)[[i]] == "") {
      quo_data <- attr(dot, "dplyr:::data")
      names(dots)[[i]] <- as_label(quo_data$name)
    }
  }

  dots
}

duckplyr_mutate_keep <- function(out, keep, used, names_new, names_groups) {
  if (keep == "all") {
    return(out)
  }

  names <- names(out)

  names_keep <- switch(keep,
    used = names(used)[used],
    unused = names(used)[!used],
    none = character(),
    abort("Unknown `keep`.", .internal = TRUE)
  )

  names_out <- intersect(names, c(names_new, names_groups, names_keep))

  select(out, !!!names_out)
}

duckdb <- asNamespace("duckdb")

# A simplified version of functions in dplyr's across.R

duckplyr_expand_across <- function(data, quo) {
  stopifnot(is.character(data))

  quo_data <- attr(quo, "dplyr:::data")
  if (!quo_is_call(quo, "across", ns = c("", "dplyr")) || quo_data$is_named) {
    return(NULL)
  }

  # Expand dots in lexical env
  env <- quo_get_env(quo)
  expr <- match.call(
    definition = dplyr::across,
    call = quo_get_expr(quo),
    expand.dots = FALSE,
    envir = env
  )

  # Abort expansion if there are any expression supplied because dots
  # must be evaluated once per group in the data mask. Expanding the
  # `across()` call would lead to either `n_group * n_col` evaluations
  # if dots are delayed or only 1 evaluation if they are eagerly
  # evaluated.
  if (!is_null(expr$...)) {
    return(NULL)
  }

  if (".unpack" %in% names(expr)) {
    # In dplyr this evaluates in the mask to reproduce the `mutate()` or
    # `summarise()` context. We don't have a mask here but it's probably fine in
    # almost all cases.
    unpack <- eval_tidy(expr$.unpack, env = env)
  } else {
    unpack <- FALSE
  }

  # Abort expansion if unpacking as expansion makes named expressions and we
  # need the expressions to remain unnamed
  if (!is_false(unpack)) {
    return(NULL)
  }

  # Differentiate between missing and null (`match.call()` doesn't
  # expand default argument)
  if (!(".cols" %in% names(expr))) {
    # This is deprecated, let dplyr warn
    return(NULL)
  }

  if (!(".fns" %in% names(expr))) {
    # To be deprecated, let dplyr deal with this
    return(NULL)
  }

  cols <- as_quosure(expr$.cols, env)

  fns <- as_quosure(expr$.fns, env)
  fns <- quo_eval_fns(fns, mask = env, error_call = error_call)

  # In dplyr this evaluates in the mask to reproduce the `mutate()` or
  # `summarise()` context. We don't have a mask here but it's probably fine in
  # almost all cases.
  names <- eval_tidy(expr$.names, env = env)

  setup <- duckplyr_across_setup(
    data,
    cols,
    fns = fns,
    names = names,
    .caller_env = env,
    error_call = error_call
  )

  vars <- setup$vars

  # Empty expansion
  if (length(vars) == 0L) {
    return(NULL)
  }

  fns <- setup$fns
  names <- setup$names %||% vars

  n_vars <- length(vars)
  n_fns <- length(fns)

  seq_vars <- seq_len(n_vars)
  seq_fns  <- seq_len(n_fns)

  exprs <- new_list(n_vars * n_fns, names = names)

  k <- 1L
  for (i in seq_vars) {
    var <- vars[[i]]

    for (j in seq_fns) {
      # Note: `mask` isn't actually used inside this helper
      fn_call <- as_across_fn_call(fn_to_expr(fns[[j]], env), var, env, mask = env)

      name <- names[[k]]

      exprs[[k]] <- new_dplyr_quosure(
        fn_call,
        name = name,
        is_named = TRUE,
        index = c(quo_data$index, k),
        column = var
      )

      k <- k + 1L
    }
  }

  exprs
}

duckplyr_across_setup <- function(data,
                                  cols,
                                  fns,
                                  names,
                                  .caller_env,
                                  error_call = caller_env()) {
  data <- set_names(seq_along(data), data)

  vars <- tidyselect::eval_select(
    cols,
    data = data,
    allow_predicates = FALSE,
    error_call = error_call
  )
  names_vars <- names(vars)
  vars <- names(data)[vars]

  names_fns <- names(fns)

  # apply `.names` smart default
  if (is.function(fns)) {
    names <- names %||% "{.col}"
    fns <- list("1" = fns)
  } else {
    names <- names %||% "{.col}_{.fn}"
  }

  if (!is.list(fns)) {
    abort("Expected a list.", .internal = TRUE)
  }

  # make sure fns has names, use number to replace unnamed
  if (is.null(names(fns))) {
    names_fns <- seq_along(fns)
  } else {
    names_fns <- names(fns)
    empties <- which(names_fns == "")
    if (length(empties)) {
      names_fns[empties] <- empties
    }
  }

  glue_mask <- across_glue_mask(.caller_env,
    .col = rep(names_vars, each = length(fns)),
    .fn  = rep(names_fns , length(vars))
  )
  names <- vec_as_names(
    glue(names, .envir = glue_mask),
    repair = "check_unique",
    call = error_call
  )

  list(
    vars = vars,
    fns = fns,
    names = names
  )
}

fn_to_expr <- function(fn, env) {
  fn_env <- environment(fn)
  if (!is_namespace(fn_env)) {
    return(fn)
  }

  # This is an environment that maps hashes to function names
  ns_exports_lookup <- get_ns_exports_lookup(fn_env)

  # Can we find the function among the exports in the namespace?
  fun_name <- ns_exports_lookup[[hash(fn)]]
  if (is.null(fun_name)) {
    return(fn)
  }

  # Triple-check: Does the expression actually evaluate to fn?
  ns_name <- getNamespaceName(fn_env)
  out <- call2("::", sym(ns_name), sym(fun_name))
  if (!identical(eval(out, env), fn)) {
    return(fn)
  }

  out
}

# Memoize get_ns_exports_lookup() to avoid recomputing the hash of
# every function in every namespace every time
on_load({
  get_ns_exports_lookup <<- memoise::memoise(get_ns_exports_lookup)
})

get_ns_exports_lookup <- function(ns) {
  names <- getNamespaceExports(ns)
  objs <- mget(names, ns)
  funs <- objs[map_lgl(objs, is.function)]

  hashes <- map_chr(funs, hash)
  # Reverse, return as environment
  new_environment(set_names(as.list(names(hashes)), hashes))
}

test_duckplyr_expand_across <- function(data, expr) {
  quo <- new_dplyr_quosure(enquo(expr), is_named = FALSE, index = 1L)
  out <- duckplyr_expand_across(data, quo)
  if (is.null(out)) {
    return(NULL)
  }
  call2(rlang::expr(tibble), !!!map(out, quo_get_expr))
}

#' Execute a statement for the default connection
#'
#' The \pkg{duckplyr} package relies on a DBI connection
#' to an in-memory database.
#' The `duckplyr_execute()` function allows running SQL statements
#' with this connection to, e.g., set up credentials
#' or attach other databases.
#'
#' @param sql The statement to run.
#' @return The return value of the [DBI::dbExecute()] call, invisibly.
#' @export
#' @examples
#' duckplyr_execute("SET threads TO 2")
duckplyr_execute <- function(sql) {
  con <- get_default_duckdb_connection()
  invisible(DBI::dbExecute(con, sql))
}

#' @export
explain.data.frame <- function(x, ...) {
  rel_try(list(name = "explain", x = x),
    "No restrictions" = FALSE,
    {
      rel <- duckdb_rel_from_df(x)
      rel_explain(rel)
      return(invisible())
    }
  )

  writeLines("Can't convert to relational, fallback implementation will be used.")
  invisible()
}

# Generated by 02-duckplyr_df-methods.R

filter.data.frame <- function(.data, ..., .by = NULL, .preserve = FALSE) {
  force(.data)

  dots <- dplyr_quosures(...)
  check_filter(dots)

  by <- enquo(.by)

  rel_try(list(name = "filter", x = .data, args = list(dots = dots, by = by, preserve = .preserve)),
    "Can't use relational with zero-column result set." = (length(.data) == 0),
    "Can't use relational without filter conditions." = (length(dots) == 0),
    "Can't use relational with grouped operation." = (!quo_is_null(by)), # (length(by$names) > 0),
    {
      exprs <- rel_translate_dots(dots, .data)
      rel <- duckdb_rel_from_df(.data)

      # FIXME: Seems to be necessary only if alternations `|` are used in `exprs`.
      # Add only then?
      rel <- oo_prep(rel)

      rel <- rel_filter(rel, exprs)

      out_rel <- oo_restore(rel)

      out <- rel_to_df(out_rel)
      out <- dplyr_reconstruct(out, .data)
      return(out)
    }
  )

  # dplyr forward
  filter <- filter_data_frame
  out <- filter(.data, ..., .by = {{ .by }}, .preserve = .preserve)
  return(out)

  # dplyr implementation
  dots <- dplyr_quosures(...)
  check_filter(dots)

  by <- compute_by(
    by = {{ .by }},
    data = .data,
    by_arg = ".by",
    data_arg = ".data"
  )

  loc <- filter_rows(.data, dots, by)
  dplyr_row_slice(.data, loc, preserve = .preserve)
}

duckplyr_filter <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- filter(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
full_join.data.frame <- function(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ..., keep = NULL, na_matches = c("na", "never"), multiple = "all", relationship = NULL) {
  check_dots_empty0(...)
  error_call <- caller_env()
  y <- auto_copy(x, y, copy = copy)

  # Our implementation
  rel_try(list(name = "full_join", x = x, y = y, args = list(by = if (!is.null(by) && !is_cross_by(by)) as_join_by(by), copy = copy, keep = keep, na_matches = na_matches, multiple = multiple, relationship = relationship)),
    "No implicit cross joins for full_join()" = is_cross_by(by),
    {
      out <- rel_join_impl(x, y, by, "full", na_matches, suffix, keep, error_call)
      return(out)
    }
  )

  # dplyr forward
  full_join <- full_join_data_frame
  out <- full_join(x, y, by, copy = FALSE, suffix, ..., keep = keep, na_matches = na_matches, multiple = multiple, relationship = relationship)
  return(out)

  # dplyr implementation
  check_dots_empty0(...)
  y <- auto_copy(x, y, copy = copy)
  join_mutate(
    x = x,
    y = y,
    by = by,
    type = "full",
    suffix = suffix,
    na_matches = na_matches,
    keep = keep,
    multiple = multiple,
    # All keys from both inputs are retained. Erroring never makes sense.
    unmatched = "drop",
    relationship = relationship,
    user_env = caller_env()
  )
}

duckplyr_full_join <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- full_join(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by roxyglobals: do not edit by hand

utils::globalVariables(c(
  "lineitem", # <tpch_01>
  "l_shipdate", # <tpch_01>
  "l_returnflag", # <tpch_01>
  "l_linestatus", # <tpch_01>
  "l_quantity", # <tpch_01>
  "l_extendedprice", # <tpch_01>
  "l_discount", # <tpch_01>
  "l_tax", # <tpch_01>
  "partsupp", # <tpch_02>
  "ps_partkey", # <tpch_02>
  "ps_suppkey", # <tpch_02>
  "ps_supplycost", # <tpch_02>
  "part", # <tpch_02>
  "p_partkey", # <tpch_02>
  "p_type", # <tpch_02>
  "p_size", # <tpch_02>
  "p_mfgr", # <tpch_02>
  "supplier", # <tpch_02>
  "s_suppkey", # <tpch_02>
  "s_nationkey", # <tpch_02>
  "s_acctbal", # <tpch_02>
  "s_name", # <tpch_02>
  "s_address", # <tpch_02>
  "s_phone", # <tpch_02>
  "s_comment", # <tpch_02>
  "nation", # <tpch_02>
  "region", # <tpch_02>
  "r_name", # <tpch_02>
  "n_nationkey", # <tpch_02>
  "n_name", # <tpch_02>
  "orders", # <tpch_03>
  "o_orderkey", # <tpch_03>
  "o_custkey", # <tpch_03>
  "o_orderdate", # <tpch_03>
  "o_shippriority", # <tpch_03>
  "customer", # <tpch_03>
  "c_custkey", # <tpch_03>
  "c_mktsegment", # <tpch_03>
  "lineitem", # <tpch_03>
  "l_orderkey", # <tpch_03>
  "l_shipdate", # <tpch_03>
  "l_extendedprice", # <tpch_03>
  "l_discount", # <tpch_03>
  "volume", # <tpch_03>
  "revenue", # <tpch_03>
  "lineitem", # <tpch_04>
  "l_orderkey", # <tpch_04>
  "l_commitdate", # <tpch_04>
  "l_receiptdate", # <tpch_04>
  "orders", # <tpch_04>
  "o_orderkey", # <tpch_04>
  "o_orderdate", # <tpch_04>
  "o_orderpriority", # <tpch_04>
  "nation", # <tpch_05>
  "n_nationkey", # <tpch_05>
  "n_regionkey", # <tpch_05>
  "n_name", # <tpch_05>
  "region", # <tpch_05>
  "r_regionkey", # <tpch_05>
  "r_name", # <tpch_05>
  "supplier", # <tpch_05>
  "s_suppkey", # <tpch_05>
  "s_nationkey", # <tpch_05>
  "lineitem", # <tpch_05>
  "l_suppkey", # <tpch_05>
  "l_orderkey", # <tpch_05>
  "l_extendedprice", # <tpch_05>
  "l_discount", # <tpch_05>
  "orders", # <tpch_05>
  "o_orderdate", # <tpch_05>
  "o_orderkey", # <tpch_05>
  "o_custkey", # <tpch_05>
  "customer", # <tpch_05>
  "c_custkey", # <tpch_05>
  "c_nationkey", # <tpch_05>
  "volume", # <tpch_05>
  "revenue", # <tpch_05>
  "lineitem", # <tpch_06>
  "l_shipdate", # <tpch_06>
  "l_extendedprice", # <tpch_06>
  "l_discount", # <tpch_06>
  "l_quantity", # <tpch_06>
  "supplier", # <tpch_07>
  "s_nationkey", # <tpch_07>
  "s_suppkey", # <tpch_07>
  "nation", # <tpch_07>
  "n_nationkey", # <tpch_07>
  "n_name", # <tpch_07>
  "n1_name", # <tpch_07>
  "customer", # <tpch_07>
  "c_custkey", # <tpch_07>
  "c_nationkey", # <tpch_07>
  "n2_name", # <tpch_07>
  "orders", # <tpch_07>
  "o_custkey", # <tpch_07>
  "o_orderkey", # <tpch_07>
  "lineitem", # <tpch_07>
  "l_orderkey", # <tpch_07>
  "l_suppkey", # <tpch_07>
  "l_shipdate", # <tpch_07>
  "l_extendedprice", # <tpch_07>
  "l_discount", # <tpch_07>
  "supp_nation", # <tpch_07>
  "cust_nation", # <tpch_07>
  "l_year", # <tpch_07>
  "volume", # <tpch_07>
  "nation", # <tpch_08>
  "n_nationkey", # <tpch_08>
  "n_regionkey", # <tpch_08>
  "region", # <tpch_08>
  "r_regionkey", # <tpch_08>
  "r_name", # <tpch_08>
  "n1_nationkey", # <tpch_08>
  "customer", # <tpch_08>
  "c_custkey", # <tpch_08>
  "c_nationkey", # <tpch_08>
  "orders", # <tpch_08>
  "o_orderkey", # <tpch_08>
  "o_custkey", # <tpch_08>
  "o_orderdate", # <tpch_08>
  "lineitem", # <tpch_08>
  "l_orderkey", # <tpch_08>
  "l_partkey", # <tpch_08>
  "l_suppkey", # <tpch_08>
  "l_extendedprice", # <tpch_08>
  "l_discount", # <tpch_08>
  "part", # <tpch_08>
  "p_partkey", # <tpch_08>
  "p_type", # <tpch_08>
  "supplier", # <tpch_08>
  "s_suppkey", # <tpch_08>
  "s_nationkey", # <tpch_08>
  "n_name", # <tpch_08>
  "n2_name", # <tpch_08>
  "o_year", # <tpch_08>
  "volume", # <tpch_08>
  "part", # <tpch_09>
  "p_name", # <tpch_09>
  "p_partkey", # <tpch_09>
  "partsupp", # <tpch_09>
  "ps_suppkey", # <tpch_09>
  "ps_partkey", # <tpch_09>
  "ps_supplycost", # <tpch_09>
  "supplier", # <tpch_09>
  "s_suppkey", # <tpch_09>
  "s_nationkey", # <tpch_09>
  "nation", # <tpch_09>
  "n_nationkey", # <tpch_09>
  "n_name", # <tpch_09>
  "lineitem", # <tpch_09>
  "l_suppkey", # <tpch_09>
  "l_partkey", # <tpch_09>
  "l_orderkey", # <tpch_09>
  "l_extendedprice", # <tpch_09>
  "l_discount", # <tpch_09>
  "l_quantity", # <tpch_09>
  "orders", # <tpch_09>
  "o_orderkey", # <tpch_09>
  "o_orderdate", # <tpch_09>
  "o_year", # <tpch_09>
  "amount", # <tpch_09>
  "lineitem", # <tpch_10>
  "l_orderkey", # <tpch_10>
  "l_returnflag", # <tpch_10>
  "l_extendedprice", # <tpch_10>
  "l_discount", # <tpch_10>
  "orders", # <tpch_10>
  "o_orderkey", # <tpch_10>
  "o_custkey", # <tpch_10>
  "o_orderdate", # <tpch_10>
  "volume", # <tpch_10>
  "customer", # <tpch_10>
  "c_custkey", # <tpch_10>
  "c_nationkey", # <tpch_10>
  "c_name", # <tpch_10>
  "c_acctbal", # <tpch_10>
  "c_phone", # <tpch_10>
  "c_address", # <tpch_10>
  "c_comment", # <tpch_10>
  "nation", # <tpch_10>
  "n_nationkey", # <tpch_10>
  "n_name", # <tpch_10>
  "revenue", # <tpch_10>
  "n_name", # <tpch_11>
  "partsupp", # <tpch_11>
  "supplier", # <tpch_11>
  "ps_supplycost", # <tpch_11>
  "ps_availqty", # <tpch_11>
  "ps_partkey", # <tpch_11>
  "value", # <tpch_11>
  "global_value", # <tpch_11>
  "lineitem", # <tpch_12>
  "l_shipmode", # <tpch_12>
  "l_commitdate", # <tpch_12>
  "l_receiptdate", # <tpch_12>
  "l_shipdate", # <tpch_12>
  "orders", # <tpch_12>
  "o_orderpriority", # <tpch_12>
  "customer", # <tpch_13>
  "orders", # <tpch_13>
  "o_comment", # <tpch_13>
  "o_orderkey", # <tpch_13>
  "c_custkey", # <tpch_13>
  "c_count", # <tpch_13>
  "custdist", # <tpch_13>
  "lineitem", # <tpch_14>
  "l_shipdate", # <tpch_14>
  "part", # <tpch_14>
  "p_type", # <tpch_14>
  "l_extendedprice", # <tpch_14>
  "l_discount", # <tpch_14>
  "lineitem", # <tpch_15>
  "l_shipdate", # <tpch_15>
  "l_extendedprice", # <tpch_15>
  "l_discount", # <tpch_15>
  "l_suppkey", # <tpch_15>
  "total_revenue", # <tpch_15>
  "global_agr_key", # <tpch_15>
  "max_total_revenue", # <tpch_15>
  "supplier", # <tpch_15>
  "s_name", # <tpch_15>
  "s_address", # <tpch_15>
  "s_phone", # <tpch_15>
  "part", # <tpch_16>
  "p_brand", # <tpch_16>
  "p_type", # <tpch_16>
  "p_size", # <tpch_16>
  "supplier", # <tpch_16>
  "s_comment", # <tpch_16>
  "partsupp", # <tpch_16>
  "ps_partkey", # <tpch_16>
  "ps_suppkey", # <tpch_16>
  "supplier_cnt", # <tpch_16>
  "part", # <tpch_17>
  "p_brand", # <tpch_17>
  "p_container", # <tpch_17>
  "lineitem", # <tpch_17>
  "l_quantity", # <tpch_17>
  "l_partkey", # <tpch_17>
  "quantity_threshold", # <tpch_17>
  "l_extendedprice", # <tpch_17>
  "lineitem", # <tpch_18>
  "l_quantity", # <tpch_18>
  "l_orderkey", # <tpch_18>
  "orders", # <tpch_18>
  "customer", # <tpch_18>
  "c_name", # <tpch_18>
  "o_custkey", # <tpch_18>
  "o_orderkey", # <tpch_18>
  "o_orderdate", # <tpch_18>
  "o_totalprice", # <tpch_18>
  "lineitem", # <tpch_19>
  "part", # <tpch_19>
  "p_brand", # <tpch_19>
  "p_container", # <tpch_19>
  "l_quantity", # <tpch_19>
  "p_size", # <tpch_19>
  "l_shipmode", # <tpch_19>
  "l_shipinstruct", # <tpch_19>
  "l_extendedprice", # <tpch_19>
  "l_discount", # <tpch_19>
  "supplier", # <tpch_20>
  "nation", # <tpch_20>
  "n_name", # <tpch_20>
  "s_suppkey", # <tpch_20>
  "s_name", # <tpch_20>
  "s_address", # <tpch_20>
  "part", # <tpch_20>
  "p_name", # <tpch_20>
  "partsupp", # <tpch_20>
  "lineitem", # <tpch_20>
  "l_shipdate", # <tpch_20>
  "l_quantity", # <tpch_20>
  "l_suppkey", # <tpch_20>
  "ps_availqty", # <tpch_20>
  "lineitem", # <tpch_21>
  "l_orderkey", # <tpch_21>
  "l_suppkey", # <tpch_21>
  "n_supplier", # <tpch_21>
  "orders", # <tpch_21>
  "o_orderstatus", # <tpch_21>
  "l_receiptdate", # <tpch_21>
  "l_commitdate", # <tpch_21>
  "failed_delivery_commit", # <tpch_21>
  "num_failed", # <tpch_21>
  "supplier", # <tpch_21>
  "nation", # <tpch_21>
  "n_name", # <tpch_21>
  "s_name", # <tpch_21>
  "numwait", # <tpch_21>
  "customer", # <tpch_22>
  "c_phone", # <tpch_22>
  "c_acctbal", # <tpch_22>
  "cntrycode", # <tpch_22>
  "acctbal_min", # <tpch_22>
  "orders", # <tpch_22>
  NULL
))

# Generated by 02-duckplyr_df-methods.R
#' @export
group_by.data.frame <- function(.data, ..., .add = FALSE, .drop = group_by_drop_default(.data)) {
  # Our implementation
  rel_try(NULL,
    # Always fall back to dplyr
    "No relational implementation for group_by()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  group_by <- group_by_data_frame
  out <- group_by(.data, ..., .add = .add, .drop = .drop)
  return(out)

  # dplyr implementation
  groups <- group_by_prepare(
    .data,
    ...,
    .add = .add,
    error_call = current_env()
  )
  grouped_df(groups$data, groups$group_names, .drop)
}

duckplyr_group_by <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- group_by(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
group_indices.data.frame <- function(.data, ...) {
  # Our implementation
  rel_try(NULL,
    # Always fall back to dplyr
    "No relational implementation for group_indices()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  group_indices <- group_indices_data_frame
  out <- group_indices(.data, ...)
  return(out)

  # dplyr implementation
  if (dots_n(...) > 0) {
    lifecycle::deprecate_warn(
      "1.0.0", "group_indices(... = )",
      details = "Please `group_by()` first",
      always = TRUE
    )
    .data <- group_by(.data, ...)
  }

  # .Call(`dplyr_group_indices`, .data, group_rows(.data))
}

duckplyr_group_indices <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- group_indices(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
group_keys.data.frame <- function(.tbl, ...) {
  # Our implementation
  rel_try(NULL,
    # Always fall back to dplyr
    "No relational implementation for group_keys()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  group_keys <- group_keys_data_frame
  out <- group_keys(.tbl, ...)
  return(out)

  # dplyr implementation
  if (dots_n(...) > 0) {
    lifecycle::deprecate_warn(
      "1.0.0", "group_keys(... = )",
      details = "Please `group_by()` first",
      always = TRUE
    )
    .tbl <- group_by(.tbl, ...)
  }
  out <- group_data(.tbl)
  group_keys0(out)
}

duckplyr_group_keys <- function(.tbl, ...) {
  try_fetch(
    .tbl <- as_duckplyr_df(.tbl),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- group_keys(.tbl, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
group_map.data.frame <- function(.data, .f, ..., .keep = FALSE, keep = deprecated()) {
  if (!missing(keep)) {
    lifecycle::deprecate_warn("1.0.0", "group_map(keep = )", "group_map(.keep = )", always = TRUE)
    .keep <- keep
  }

  # Our implementation
  rel_try(NULL,
    # Always fall back to dplyr
    "No relational implementation for group_map()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  group_map <- group_map_data_frame
  out <- group_map(.data, .f, ..., .keep = .keep)
  return(out)

  # dplyr implementation
  if (!missing(keep)) {
    lifecycle::deprecate_warn("1.0.0", "group_map(keep = )", "group_map(.keep = )", always = TRUE)
    .keep <- keep
  }
  .f <- as_group_map_function(.f)

  # call the function on each group
  chunks <- if (is_grouped_df(.data)) {
    group_split(.data, .keep = isTRUE(.keep))
  } else {
    group_split(.data)
  }
  keys <- group_keys(.data)
  group_keys <- map(seq_len(nrow(keys)), function(i) keys[i, , drop = FALSE])

  if (length(chunks)) {
    map2(chunks, group_keys, .f, ...)
  } else {
    # calling .f with .x and .y set to prototypes
    structure(list(), ptype = .f(attr(chunks, "ptype"), keys[integer(0L), ], ...))
  }
}

duckplyr_group_map <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- group_map(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
group_modify.data.frame <- function(.data, .f, ..., .keep = FALSE, keep = deprecated()) {
  if (!missing(keep)) {
    lifecycle::deprecate_warn("1.0.0", "group_modify(keep = )", "group_modify(.keep = )", always = TRUE)
    .keep <- keep
  }

  # Our implementation
  rel_try(NULL,
    # Always fall back to dplyr
    "No relational implementation for group_modify()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  group_modify <- group_modify_data_frame
  out <- group_modify(.data, .f, ..., .keep = .keep)
  return(out)

  # dplyr implementation
  if (!missing(keep)) {
    lifecycle::deprecate_warn("1.0.0", "group_modify(keep = )", "group_modify(.keep = )", always = TRUE)
    .keep <- keep
  }
  .f <- as_group_map_function(.f)
  .f(.data, group_keys(.data), ...)
}

duckplyr_group_modify <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- group_modify(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
group_nest.data.frame <- function(.tbl, ..., .key = "data", keep = FALSE) {
  # Our implementation
  rel_try(NULL,
    # Always fall back to dplyr
    "No relational implementation for group_nest()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  group_nest <- group_nest_data_frame
  out <- group_nest(.tbl, ..., .key = .key, keep = keep)
  return(out)

  # dplyr implementation
  if (dots_n(...)) {
    group_nest_impl(group_by(.tbl, ...), .key = .key, keep = keep)
  } else {
    tibble(!!.key := list(.tbl))
  }
}

duckplyr_group_nest <- function(.tbl, ...) {
  try_fetch(
    .tbl <- as_duckplyr_df(.tbl),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- group_nest(.tbl, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
group_size.data.frame <- function(x) {
  # Our implementation
  rel_try(NULL,
    # Always fall back to dplyr
    "No relational implementation for group_size()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  group_size <- group_size_data_frame
  out <- group_size(x)
  return(out)

  # dplyr implementation
  lengths(group_rows(x))
}

duckplyr_group_size <- function(x, ...) {
  try_fetch(
    x <- as_duckplyr_df(x),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- group_size(x, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
group_split.data.frame <- function(.tbl, ..., .keep = TRUE, keep = deprecated()) {
  if (!missing(keep)) {
    lifecycle::deprecate_warn("1.0.0", "group_split(keep = )", "group_split(.keep = )", always = TRUE)
    .keep <- keep
  }

  # Our implementation
  rel_try(NULL,
    # Always fall back to dplyr
    "No relational implementation for group_split()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  group_split <- group_split_data_frame
  out <- group_split(.tbl, ..., .keep = .keep)
  return(out)

  # dplyr implementation
  if (!missing(keep)) {
    lifecycle::deprecate_warn("1.0.0", "group_split(keep = )", "group_split(.keep = )", always = TRUE)
    .keep <- keep
  }
  data <- group_by(.tbl, ...)
  group_split_impl(data, .keep = .keep)
}

duckplyr_group_split <- function(.tbl, ...) {
  try_fetch(
    .tbl <- as_duckplyr_df(.tbl),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- group_split(.tbl, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
group_trim.data.frame <- function(.tbl, .drop = group_by_drop_default(.tbl)) {
  # Our implementation
  rel_try(NULL,
    # Always fall back to dplyr
    "No relational implementation for group_trim()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  group_trim <- group_trim_data_frame
  out <- group_trim(.tbl, .drop)
  return(out)

  # dplyr implementation
  .tbl
}

duckplyr_group_trim <- function(.tbl, ...) {
  try_fetch(
    .tbl <- as_duckplyr_df(.tbl),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- group_trim(.tbl, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
group_vars.data.frame <- function(x) {
  if (inherits(x, c("grouped_df", "rowwise_df"))) {
    return(group_vars_data_frame(x))
  }

  # Avoid calling group_data()
  character()
}

duckplyr_group_vars <- function(x, ...) {
  try_fetch(
    x <- as_duckplyr_df(x),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- group_vars(x, ...)
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
groups.data.frame <- function(x) {
  # Our implementation
  rel_try(NULL,
    # Always fall back to dplyr
    "No relational implementation for groups()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  groups <- groups_data_frame
  out <- groups(x)
  return(out)

  # dplyr implementation
  syms(group_vars(x))
}

duckplyr_groups <- function(x, ...) {
  try_fetch(
    x <- as_duckplyr_df(x),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- groups(x, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Used in arrange()
handle_desc <- function(dots) {
  # Handles calls to 'desc' function by
  # - extracting the sort order
  # - removing any desc-function calls from the expressions: desc(colname) -> colname
  ascending <- rep(TRUE, length(dots))

  for (i in seq_along(dots)) {
    expr <- quo_get_expr(dots[[i]])

    if (!is.call(expr)) next
    if (expr[[1]] != "desc") next

    # Check that desc is called with a single argument
    # (dplyr::desc() accepts only one argument)
    if (length(expr) > 2) cli::cli_abort("`desc()` must be called with exactly one argument.")

    ascending[i] <- FALSE
    dots[[i]] <- new_quosure(expr[[2]], env = quo_get_env(dots[[i]]))
  }

  list(dots = dots, ascending = ascending)
}

# Standalone file: do not edit by hand
# ----------------------------------------------------------------------
#
# ---
# repo: r-lib/rlang
# file: standalone-purrr.R
# last-updated: 2023-02-23
# license: https://unlicense.org
# imports: rlang
# ---
#
# This file provides a minimal shim to provide a purrr-like API on top of
# base R functions. They are not drop-in replacements but allow a similar style
# of programming.
#
# ## Changelog
#
# 2023-02-23:
# * Added `list_c()`
#
# 2022-06-07:
# * `transpose()` is now more consistent with purrr when inner names
#   are not congruent (#1346).
#
# 2021-12-15:
# * `transpose()` now supports empty lists.
#
# 2021-05-21:
# * Fixed "object `x` not found" error in `imap()` (@mgirlich)
#
# 2020-04-14:
# * Removed `pluck*()` functions
# * Removed `*_cpl()` functions
# * Used `as_function()` to allow use of `~`
# * Used `.` prefix for helpers
#
# nocov start

map <- function(.x, .f, ...) {
  .f <- as_function(.f, env = global_env())
  lapply(.x, .f, ...)
}
walk <- function(.x, .f, ...) {
  map(.x, .f, ...)
  invisible(.x)
}

map_lgl <- function(.x, .f, ...) {
  .rlang_purrr_map_mold(.x, .f, logical(1), ...)
}
map_int <- function(.x, .f, ...) {
  .rlang_purrr_map_mold(.x, .f, integer(1), ...)
}
map_dbl <- function(.x, .f, ...) {
  .rlang_purrr_map_mold(.x, .f, double(1), ...)
}
map_chr <- function(.x, .f, ...) {
  .rlang_purrr_map_mold(.x, .f, character(1), ...)
}
.rlang_purrr_map_mold <- function(.x, .f, .mold, ...) {
  .f <- as_function(.f, env = global_env())
  out <- vapply(.x, .f, .mold, ..., USE.NAMES = FALSE)
  names(out) <- names(.x)
  out
}

map2 <- function(.x, .y, .f, ...) {
  .f <- as_function(.f, env = global_env())
  out <- mapply(.f, .x, .y, MoreArgs = list(...), SIMPLIFY = FALSE)
  if (length(out) == length(.x)) {
    set_names(out, names(.x))
  } else {
    set_names(out, NULL)
  }
}
map2_lgl <- function(.x, .y, .f, ...) {
  as.vector(map2(.x, .y, .f, ...), "logical")
}
map2_int <- function(.x, .y, .f, ...) {
  as.vector(map2(.x, .y, .f, ...), "integer")
}
map2_dbl <- function(.x, .y, .f, ...) {
  as.vector(map2(.x, .y, .f, ...), "double")
}
map2_chr <- function(.x, .y, .f, ...) {
  as.vector(map2(.x, .y, .f, ...), "character")
}
imap <- function(.x, .f, ...) {
  map2(.x, names(.x) %||% seq_along(.x), .f, ...)
}

pmap <- function(.l, .f, ...) {
  .f <- as.function(.f)
  args <- .rlang_purrr_args_recycle(.l)
  do.call("mapply", c(
    FUN = list(quote(.f)),
    args, MoreArgs = quote(list(...)),
    SIMPLIFY = FALSE, USE.NAMES = FALSE
  ))
}
.rlang_purrr_args_recycle <- function(args) {
  lengths <- map_int(args, length)
  n <- max(lengths)

  stopifnot(all(lengths == 1L | lengths == n))
  to_recycle <- lengths == 1L
  args[to_recycle] <- map(args[to_recycle], function(x) rep.int(x, n))

  args
}

keep <- function(.x, .f, ...) {
  .x[.rlang_purrr_probe(.x, .f, ...)]
}
discard <- function(.x, .p, ...) {
  sel <- .rlang_purrr_probe(.x, .p, ...)
  .x[is.na(sel) | !sel]
}
map_if <- function(.x, .p, .f, ...) {
  matches <- .rlang_purrr_probe(.x, .p)
  .x[matches] <- map(.x[matches], .f, ...)
  .x
}
.rlang_purrr_probe <- function(.x, .p, ...) {
  if (is_logical(.p)) {
    stopifnot(length(.p) == length(.x))
    .p
  } else {
    .p <- as_function(.p, env = global_env())
    map_lgl(.x, .p, ...)
  }
}

compact <- function(.x) {
  Filter(length, .x)
}

transpose <- function(.l) {
  if (!length(.l)) {
    return(.l)
  }

  inner_names <- names(.l[[1]])

  if (is.null(inner_names)) {
    fields <- seq_along(.l[[1]])
  } else {
    fields <- set_names(inner_names)
    .l <- map(.l, function(x) {
      if (is.null(names(x))) {
        set_names(x, inner_names)
      } else {
        x
      }
    })
  }

  # This way missing fields are subsetted as `NULL` instead of causing
  # an error
  .l <- map(.l, as.list)

  map(fields, function(i) {
    map(.l, .subset2, i)
  })
}

every <- function(.x, .p, ...) {
  .p <- as_function(.p, env = global_env())

  for (i in seq_along(.x)) {
    if (!rlang::is_true(.p(.x[[i]], ...))) return(FALSE)
  }
  TRUE
}
some <- function(.x, .p, ...) {
  .p <- as_function(.p, env = global_env())

  for (i in seq_along(.x)) {
    if (rlang::is_true(.p(.x[[i]], ...))) return(TRUE)
  }
  FALSE
}
negate <- function(.p) {
  .p <- as_function(.p, env = global_env())
  function(...) !.p(...)
}

reduce <- function(.x, .f, ..., .init) {
  f <- function(x, y) .f(x, y, ...)
  Reduce(f, .x, init = .init)
}
reduce_right <- function(.x, .f, ..., .init) {
  f <- function(x, y) .f(y, x, ...)
  Reduce(f, .x, init = .init, right = TRUE)
}
accumulate <- function(.x, .f, ..., .init) {
  f <- function(x, y) .f(x, y, ...)
  Reduce(f, .x, init = .init, accumulate = TRUE)
}
accumulate_right <- function(.x, .f, ..., .init) {
  f <- function(x, y) .f(y, x, ...)
  Reduce(f, .x, init = .init, right = TRUE, accumulate = TRUE)
}

detect <- function(.x, .f, ..., .right = FALSE, .p = is_true) {
  .p <- as_function(.p, env = global_env())
  .f <- as_function(.f, env = global_env())

  for (i in .rlang_purrr_index(.x, .right)) {
    if (.p(.f(.x[[i]], ...))) {
      return(.x[[i]])
    }
  }
  NULL
}
detect_index <- function(.x, .f, ..., .right = FALSE, .p = is_true) {
  .p <- as_function(.p, env = global_env())
  .f <- as_function(.f, env = global_env())

  for (i in .rlang_purrr_index(.x, .right)) {
    if (.p(.f(.x[[i]], ...))) {
      return(i)
    }
  }
  0L
}
.rlang_purrr_index <- function(x, right = FALSE) {
  idx <- seq_along(x)
  if (right) {
    idx <- rev(idx)
  }
  idx
}

list_c <- function(x) {
  inject(c(!!!x))
}

# nocov end

# Generated by 02-duckplyr_df-methods.R
#' @export
inner_join.data.frame <- function(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ..., keep = NULL, na_matches = c("na", "never"), multiple = "all", unmatched = "drop", relationship = NULL) {
  check_dots_empty0(...)
  error_call <- caller_env()
  y <- auto_copy(x, y, copy = copy)

  # Our implementation
  rel_try(list(name = "inner_join", x = x, y = y, args = list(by = if (!is.null(by) && !is_cross_by(by)) as_join_by(by), copy = copy, keep = keep, na_matches = na_matches, multiple = multiple, unmatched = unmatched, relationship = relationship)),
    "No implicit cross joins for inner_join()" = is_cross_by(by),
    {
      out <- rel_join_impl(x, y, by, "inner", na_matches, suffix, keep, error_call)
      return(out)
    }
  )

  # dplyr forward
  inner_join <- inner_join_data_frame
  out <- inner_join(x, y, by, copy = FALSE, suffix, ..., keep = keep, na_matches = na_matches, multiple = multiple, unmatched = unmatched, relationship = relationship)
  return(out)

  # dplyr implementation
  check_dots_empty0(...)
  y <- auto_copy(x, y, copy = copy)
  join_mutate(
    x = x,
    y = y,
    by = by,
    type = "inner",
    suffix = suffix,
    na_matches = na_matches,
    keep = keep,
    multiple = multiple,
    unmatched = unmatched,
    relationship = relationship,
    user_env = caller_env()
  )
}

duckplyr_inner_join <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- inner_join(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
intersect.data.frame <- function(x, y, ...) {
  # Our implementation
  check_dots_empty()
  check_compatible(x, y)

  x_names <- names(x)
  y_names <- names(y)
  if (identical(x_names, y_names)) {
    # Ensure identical() is very cheap
    y_names <- x_names
  }

  rel_try(list(name = "intersect", x = x, y = y),
    "No duplicate names" = !identical(x_names, y_names) && anyDuplicated(x_names) && anyDuplicated(y_names),
    "Tables of different width" = length(x_names) != length(y_names),
    "Name mismatch" = !identical(x_names, y_names) && !all(y_names %in% x_names),
    {
      if (oo_force()) {
        both <- semi_join(x, y, by = x_names)
        out <- distinct(both)
      } else {
        x_rel <- duckdb_rel_from_df(x)
        y_rel <- duckdb_rel_from_df(y)
        if (!identical(x_names, y_names)) {
          # FIXME: Select by position
          exprs <- nexprs_from_loc(x_names, set_names(seq_along(x_names), x_names))
          y_rel <- rel_project(y_rel, exprs)
        }

        rel <- rel_set_intersect(x_rel, y_rel)
        out <- rel_to_df(rel)
        out <- dplyr_reconstruct(out, x)
      }
      return(out)
    }
  )

  # dplyr forward
  intersect <- intersect_data_frame
  out <- intersect(x, y, ...)
  return(out)

  # dplyr implementation
  check_dots_empty()
  check_compatible(x, y)

  out <- vec_set_intersect(x, y, error_call = current_env())

  dplyr_reconstruct(out, x)
}

duckplyr_intersect <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- intersect(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

#' Read Parquet, CSV, and other files using DuckDB
#'
#' `df_from_file()` uses arbitrary table functions to read data.
#' See <https://duckdb.org/docs/data/overview> for a documentation
#' of the available functions and their options.
#' To read multiple files with the same schema,
#' pass a wildcard or a character vector to the `path` argument,
#'
#' @inheritParams rlang::args_dots_empty
#'
#' @param path Path to files, glob patterns `*` and `?` are supported.
#' @param table_function The name of a table-valued
#'   DuckDB function such as `"read_parquet"`,
#'   `"read_csv"`, `"read_csv_auto"` or `"read_json"`.
#' @param options Arguments to the DuckDB function
#'   indicated by `table_function`.
#' @param class The class of the output.
#'   By default, a tibble is created.
#'   The returned object will always be a data frame.
#'   Use `class = "data.frame"` or `class = character()`
#'   to create a plain data frame.
#'
#' @return A data frame for `df_from_file()`, or a `duckplyr_df` for
#'   `duckplyr_df_from_file()`, extended by the provided `class`.
#'
#' @export
df_from_file <- function(path,
                         table_function,
                         ...,
                         options = list(),
                         class = NULL) {
  check_dots_empty()

  if (!rlang::is_bare_character(path)) {
    cli::cli_abort("{.arg path} must be a character vector.")
  }

  if (length(path) != 1) {
    path <- list(path)
  }

  if (is.null(class)) {
    class <- default_df_class()
  }

  # FIXME: For some reason, it's important to create an alias here
  con <- get_default_duckdb_connection()

  out <- duckdb$rel_from_table_function(
    con,
    table_function,
    list(path),
    options
  )

  meta_rel_register_file(out, path, table_function, options)

  out <- duckdb$rel_to_altrep(out)
  class(out) <- unique(c(class, "data.frame"), fromLast = TRUE)
  out
}

#' duckplyr_df_from_file
#'
#' `duckplyr_df_from_file()` is a thin wrapper around `df_from_file()`
#' that calls `as_duckplyr_df()` on the output.
#'
#' @rdname df_from_file
#' @export
duckplyr_df_from_file <- function(
    path,
    table_function,
    ...,
    options = list(),
    class = NULL) {
  check_dots_empty()

  out <- df_from_file(path, table_function, options = options, class = class)
  as_duckplyr_df(out)
}

default_df_class <- function() {
  class(new_tibble(list()))
}

#' df_from_csv
#'
#' @description
#' These functions ingest data from a file using a table function.
#' The results are transparently converted to a data frame, but the data is only read when
#' the resulting data frame is actually accessed.
#'
#' `df_from_csv()` reads a CSV file using the `read_csv_auto()` table function.
#'
#' @rdname df_from_file
#' @export
#' @examples
#' # Create simple CSV file
#' path <- tempfile("duckplyr_test_", fileext = ".csv")
#' write.csv(data.frame(a = 1:3, b = letters[4:6]), path, row.names = FALSE)
#'
#' # Reading is immediate
#' df <- df_from_csv(path)
#'
#' # Materialization only upon access
#' names(df)
#' df$a
#'
#' # Return as tibble, specify column types:
#' df_from_file(
#'   path,
#'   "read_csv",
#'   options = list(delim = ",", types = list(c("DOUBLE", "VARCHAR"))),
#'   class = class(tibble())
#' )
df_from_csv <- function(path, ..., options = list(), class = NULL) {
  check_dots_empty()

  df_from_file(path, "read_csv_auto", options = options, class = class)
}

#' duckplyr_df_from_csv
#'
#' `duckplyr_df_from_csv()` is a thin wrapper around `df_from_csv()`
#' that calls `as_duckplyr_df()` on the output.
#'
#' @rdname df_from_file
#' @export
#' @examples
#'
#' # Read multiple file at once
#' path2 <- tempfile("duckplyr_test_", fileext = ".csv")
#' write.csv(data.frame(a = 4:6, b = letters[7:9]), path2, row.names = FALSE)
#'
#' duckplyr_df_from_csv(file.path(tempdir(), "duckplyr_test_*.csv"))
#'
#' unlink(c(path, path2))
duckplyr_df_from_csv <- function(path, ..., options = list(), class = NULL) {
  check_dots_empty()

  duckplyr_df_from_file(path, "read_csv_auto", options = options, class = class)
}

#' df_from_parquet
#'
#' @description
#' `df_from_parquet()` reads a Parquet file using the `read_parquet()` table function.
#'
#' @rdname df_from_file
#' @export
df_from_parquet <- function(path, ..., options = list(), class = NULL) {
  check_dots_empty()

  df_from_file(path, "read_parquet", options = options, class = class)
}

#' duckplyr_df_from_parquet
#'
#' `duckplyr_df_from_parquet()` is a thin wrapper around `df_from_parquet()`
#' that calls `as_duckplyr_df()` on the output.
#'
#' @rdname df_from_file
#' @export
duckplyr_df_from_parquet <- function(path, ..., options = list(), class = NULL) {
  check_dots_empty()

  duckplyr_df_from_file(path, "read_parquet", options = options, class = class)
}

#' df_to_parquet
#'
#' `df_to_parquet()` writes a data frame to a Parquet file via DuckDB.
#' If the data frame is a `duckplyr_df`, the materialization occurs outside of R.
#' An existing file will be overwritten.
#' This function requires duckdb >= 0.10.0.
#'
#' @param data A data frame to be written to disk.
#'
#' @rdname df_from_file
#' @export
#' @examples
#'
#' # Write a Parquet file:
#' path_parquet <- tempfile(fileext = ".parquet")
#' df_to_parquet(df, path_parquet)
#'
#' # With a duckplyr_df, the materialization occurs outside of R:
#' df %>%
#'   as_duckplyr_df() %>%
#'   mutate(b = a + 1) %>%
#'   df_to_parquet(path_parquet)
#'
#' duckplyr_df_from_parquet(path_parquet)
#'
#' unlink(path_parquet)
df_to_parquet <- function(data, path) {
  check_installed("duckdb", version = "0.10.0")

  rel <- duckdb_rel_from_df(data)
  duckdb$rel_to_parquet(rel, path)
}

#' Class predicate for duckplyr data frames
#'
#' Tests if the input object is of class `"duckplyr_df"`.
#'
#' @param .data The object to test
#'
#' @return `TRUE` if the input object is of class `"duckplyr_df"`,
#'   otherwise `FALSE`.
#'
#' @export
#' @examples
#' tibble(a = 1:3) %>%
#'   is_duckplyr_df()
#'
#' tibble(a = 1:3) %>%
#'   as_duckplyr_df() %>%
#'   is_duckplyr_df()
is_duckplyr_df <- function(.data) {
  inherits(.data, "duckplyr_df")
}

rel_join_impl <- function(
  x,
  y,
  by,
  join,
  na_matches,
  suffix = c(".x", ".y"),
  keep = NULL,
  error_call = caller_env()
) {
  mutating <- !(join %in% c("semi", "anti"))

  if (mutating) {
    check_keep(keep, error_call = error_call)
  }

  na_matches <- check_na_matches(na_matches, error_call = error_call)

  x_names <- tbl_vars(x)
  y_names <- tbl_vars(y)

  if (is_null(by)) {
    by <- join_by_common(x_names, y_names, error_call = error_call)
  } else {
    by <- as_join_by(by, error_call = error_call)
  }

  x_by <- by$x
  y_by <- by$y
  x_rel <- duckdb_rel_from_df(x)
  x_rel <- rel_set_alias(x_rel, "lhs")
  y_rel <- duckdb_rel_from_df(y)
  y_rel <- rel_set_alias(y_rel, "rhs")

  # FIXME: Split join_cols, https://github.com/tidyverse/dplyr/issues/7050
  vars <- join_cols(
    x_names = x_names,
    y_names = y_names,
    by = by,
    suffix = suffix,
    keep = keep,
    error_call = error_call
  )

  # vec_ptype_safe: https://github.com/r-lib/vctrs/issues/1956
  x_in <- map(as.list(x)[vars$x$key], vec_ptype_safe)
  y_in <- map(as.list(y)[vars$y$key], vec_ptype_safe)

  x_key <- as.data.frame(set_names(x_in, names(vars$x$key)))
  y_key <- as.data.frame(set_names(y_in, names(vars$x$key)))

  # Side effect: check join compatibility
  join_ptype_common(x_key, y_key, vars, error_call = error_call)

  # Rename if non-unique column names
  if (mutating) {
    if (length(intersect(x_names, y_names)) != 0) {
      x_names_remap <- paste0(x_names, "_x")
      x_by <- paste0(x_by, "_x")
      x_exprs <- exprs_from_loc(x, set_names(seq_along(x_names_remap), x_names_remap))
      x_rel <- rel_project(x_rel, x_exprs)

      y_names_remap <- paste0(y_names, "_y")
      y_by <- paste0(y_by, "_y")
      y_exprs <- exprs_from_loc(y, set_names(seq_along(y_names_remap), y_names_remap))
      y_rel <- rel_project(y_rel, y_exprs)
    } else {
      x_names_remap <- x_names
      y_names_remap <- y_names
    }
  }

  x_rel <- oo_prep(x_rel, "___row_number_x")
  if (mutating) {
    y_rel <- oo_prep(y_rel, "___row_number_y")
  }

  x_by <- map(x_by, relexpr_reference, rel = x_rel)
  y_by <- map(y_by, relexpr_reference, rel = y_rel)

  cond_by <- by$condition

  if (na_matches == "na") {
    cond_by[cond_by == "=="] <- "___eq_na_matches_na"
  }

  conds <- pmap(list(cond_by, x_by, y_by), function(...) {
    relexpr_function(..1, list(..2, ..3))
  })

  if (any(by$filter != "none")) {
    join_ref_type <- "asof"
  } else {
    join_ref_type <- "regular"
  }

  joined <- rel_join(x_rel, y_rel, conds, join, join_ref_type)

  if (mutating) {
    joined <- oo_restore_order(
      joined,
      c("___row_number_x", "___row_number_y"),
      list(x_rel, y_rel)
    )

    exprs <- c(
      nexprs_from_loc(x_names_remap, vars$x$out),
      nexprs_from_loc(y_names_remap, vars$y$out)
    )

    remap <- (is.null(keep) || is_false(keep))

    if (remap) {
      by_pos <- match(names(vars$x$key), x_names)
      # Only coalesce for equi-joins
      eq_idx <- (by$condition == "==")

      if (join == "right") {
        exprs[by_pos[eq_idx]] <- map2(y_by[eq_idx], names(vars$x$key)[eq_idx], relexpr_set_alias)
      } else {
        exprs[by_pos[eq_idx]] <- pmap(
          list(x_by[eq_idx], y_by[eq_idx], names(vars$x$key)[eq_idx]),
          function(...) {
            relexpr_function("___coalesce", list(..1, ..2), alias = ..3)
          }
        )
      }
    }

    out <- rel_project(joined, exprs)
  } else {
    out <- oo_restore(joined, "___row_number_x", list(x_rel))
  } # if (mutating)

  out <- rel_to_df(out)
  out <- dplyr_reconstruct(out, x)

  return(out)
}

# https://github.com/tidyverse/dplyr/pull/7029

join_ptype_common <- function(x, y, vars, error_call = caller_env()) {
  # Explicit `x/y_arg = ""` to avoid auto naming in `cnd$x_arg`
  ptype <- try_fetch(
    vec_ptype2(x, y, x_arg = "", y_arg = "", call = error_call),
    vctrs_error_incompatible_type = function(cnd) {
      rethrow_error_join_incompatible_type(cnd, vars, error_call)
    }
  )
  # Finalize unspecified columns (#6804)
  ptype <- vec_ptype_finalise(ptype)

  ptype
}

# Generated by 02-duckplyr_df-methods.R
#' @export
left_join.data.frame <- function(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ..., keep = NULL, na_matches = c("na", "never"), multiple = "all", unmatched = "drop", relationship = NULL) {
  check_dots_empty0(...)
  error_call <- caller_env()
  y <- auto_copy(x, y, copy = copy)

  # Our implementation
  rel_try(list(name = "left_join", x = x, y = y, args = list(by = if (!is.null(by) && !is_cross_by(by)) as_join_by(by), copy = copy, keep = keep, na_matches = na_matches, multiple = multiple, unmatched = unmatched, relationship = relationship)),
    "No implicit cross joins for left_join()" = is_cross_by(by),
    {
      out <- rel_join_impl(x, y, by, "left", na_matches, suffix, keep, error_call)
      return(out)
    }
  )

  # dplyr forward
  left_join <- left_join_data_frame
  out <- left_join(x, y, by, copy = FALSE, suffix, ..., keep = keep, na_matches = na_matches, multiple = multiple, unmatched = unmatched, relationship = relationship)
  return(out)

  # dplyr implementation
  check_dots_empty0(...)
  y <- auto_copy(x, y, copy = copy)
  join_mutate(
    x = x,
    y = y,
    by = by,
    type = "left",
    suffix = suffix,
    na_matches = na_matches,
    keep = keep,
    multiple = multiple,
    unmatched = unmatched,
    relationship = relationship,
    user_env = caller_env()
  )
}

duckplyr_left_join <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- left_join(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
mutate.data.frame <- function(.data, ..., .by = NULL, .keep = c("all", "used", "unused", "none"), .before = NULL, .after = NULL) {
  by_arg <- enquo(.by)
  keep <- arg_match(.keep)

  by_names <- eval_select_by(by_arg, .data)

  # Our implementation
  rel_try(list(name = "mutate", x = .data, args = list(dots = enquos(...), .by = by_arg, .keep = .keep)),
    "Implemented for all cases?" = FALSE,
    {
      rel <- duckdb_rel_from_df(.data)

      if (length(by_names) > 0) {
        rel <- oo_prep(rel)
      }

      dots <- dplyr_quosures(...)
      dots <- fix_auto_name(dots)
      names_dots <- names(dots)

      names_used <- character()
      names_new <- character()
      names_out <- rel_names(rel)

      # FIXME: use fewer projections
      for (i in seq_along(dots)) {
        dot <- dots[[i]]
        name_dot <- names_dots[[i]]

        # Try expanding this `dot` if we see it is an `across()` call
        expanded <- duckplyr_expand_across(names_out, dot)

        if (is.null(expanded)) {
          # Nothing we can expand, create a list with just the 1 expression to
          # loop over
          quos <- set_names(list(dot), name_dot)
        } else {
          # Actually expanded an `across()` call, make sure to fix up names
          # again with the new set of dplyr quosures
          quos <- expanded
          quos <- fix_auto_name(quos)
        }

        names_quos <- names(quos)

        # Set up `exprs` outside the loop. All expressions expanded from an
        # `across()` are evaluated together using the same projection.
        exprs <- imap(set_names(names_out), relexpr_reference, rel = NULL)

        for (j in seq_along(quos)) {
          quo <- quos[[j]]
          new <- names_quos[[j]]

          names_new <- c(names_new, new)

          new_pos <- match(new, names_out, nomatch = length(names_out) + 1L)
          new_expr <- rel_translate(quo, names_data = names_out, alias = new, partition = by_names, need_window = TRUE)
          exprs[[new_pos]] <- new_expr

          names_out[[new_pos]] <- new

          new_names_used <- intersect(attr(new_expr, "used"), names(.data))
          names_used <- c(names_used, setdiff(new_names_used, names_used))
        }

        rel <- rel_project(rel, unname(exprs))
      }

      if (length(by_names) > 0) {
        rel <- oo_restore(rel)
      }

      out <- rel_to_df(rel)

      out <- dplyr_reconstruct(out, .data)

      names_original <- names(.data)

      out <- mutate_relocate(
        out = out,
        before = {{ .before }},
        after = {{ .after }},
        names_original = names_original
      )

      used <- set_names(names(out) %in% names_used, names(out))
      names_groups <- by_names

      out <- duckplyr_mutate_keep(
        out = out,
        keep = keep,
        used = used,
        names_new = names_new,
        names_groups = names_groups
      )

      return(out)
    }
  )

  # dplyr forward
  mutate <- mutate_data_frame
  out <- mutate(.data, ..., .by = {{ .by }}, .keep = .keep, .before = {{ .before }}, .after = {{ .after }})
  return(out)

  # dplyr implementation
  keep <- arg_match0(.keep, values = c("all", "used", "unused", "none"))

  by <- compute_by({{ .by }}, .data, by_arg = ".by", data_arg = ".data")

  cols <- mutate_cols(.data, dplyr_quosures(...), by)
  used <- attr(cols, "used")

  out <- dplyr_col_modify(.data, cols)

  names_original <- names(.data)

  out <- mutate_relocate(
    out = out,
    before = {{ .before }},
    after = {{ .after }},
    names_original = names_original
  )

  names_new <- names(cols)
  names_groups <- by$names

  out <- mutate_keep(
    out = out,
    keep = keep,
    used = used,
    names_new = names_new,
    names_groups = names_groups
  )

  out
}

duckplyr_mutate <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- mutate(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Copied from dplyr, can be reexported with dplyr > 1.1.4

# Masks `ncol()` to avoid accidentally materializing ALTREP duckplyr
# data frames.
ncol <- function(x) {
  abort("Use `df_n_col()` or `mat_n_col()` instead.")
}

# Alternative to `ncol()` which avoids `dim()`.
#
# `dim()` also requires knowing the number of rows,
# which forces ALTREP duckplyr data frames to materialize.
#
# This function makes the same assertion as vctrs about data frame structure,
# i.e. if `x` inherits from `"data.frame"`, then it is a VECSXP with length
# equal to the number of columns.
df_n_col <- function(x) {
  x <- unclass(x)
  obj_check_list(x)
  length(x)
}

# In a few places we call `ncol()` on matrices, and in those
# cases we want to continue using the base version.
mat_n_col <- function(x) {
  base::ncol(x)
}

# Generated by 02-duckplyr_df-methods.R
#' @export
n_groups.data.frame <- function(x) {
  # Our implementation
  rel_try(NULL,
    # Always fall back to dplyr
    "No relational implementation for n_groups()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  n_groups <- n_groups_data_frame
  out <- n_groups(x)
  return(out)

  # dplyr implementation
  nrow(group_data(x))
}

duckplyr_n_groups <- function(x, ...) {
  try_fetch(
    x <- as_duckplyr_df(x),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- n_groups(x, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
nest_by.data.frame <- function(.data, ..., .key = "data", .keep = FALSE) {
  # Our implementation
  rel_try(NULL,
    "No relational implementation for nest_by()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  nest_by <- nest_by_data_frame
  out <- nest_by(.data, ..., .key = .key, .keep = .keep)
  return(out)

  # dplyr implementation
  .data <- group_by(.data, ...)
  # nest_by.grouped_df(.data, .key = .key, .keep = .keep)
}

duckplyr_nest_by <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- nest_by(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
nest_join.data.frame <- function(x, y, by = NULL, copy = FALSE, keep = NULL, name = NULL, ..., na_matches = c("na", "never"), unmatched = "drop") {
  # from dplyr implementation
  check_keep(keep)
  na_matches <- check_na_matches(na_matches)

  if (is.null(name)) {
    name <- as_label(enexpr(y))
  } else {
    check_string(name)
  }

  # Our implementation
  rel_try(NULL,
    "No relational implementation for nest_join()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  x_df <- x
  class(x_df) <- setdiff(class(x_df), "duckplyr_df")
  y_df <- y
  class(y_df) <- setdiff(class(y_df), "duckplyr_df")
  nest_join <- nest_join_data_frame
  out <- nest_join(x_df, y_df, by, copy, keep, name, ..., na_matches = na_matches, unmatched = unmatched)
  out <- dplyr_reconstruct(out, x)
  return(out)

  # dplyr implementation
  check_dots_empty0(...)
  check_keep(keep)
  na_matches <- check_na_matches(na_matches)

  if (is.null(name)) {
    name <- as_label(enexpr(y))
  } else {
    check_string(name)
  }

  x_names <- tbl_vars(x)
  y_names <- tbl_vars(y)

  if (is_cross_by(by)) {
    warn_join_cross_by()
    by <- new_join_by()
    cross <- TRUE
  } else {
    cross <- FALSE
  }

  if (is_null(by)) {
    by <- join_by_common(x_names, y_names)
  } else {
    by <- as_join_by(by)
  }

  vars <- join_cols(x_names, y_names, by = by, suffix = c("", ""), keep = keep)
  y <- auto_copy(x, y, copy = copy)

  x_in <- as_tibble(x, .name_repair = "minimal")
  y_in <- as_tibble(y, .name_repair = "minimal")

  x_key <- set_names(x_in[vars$x$key], names(vars$x$key))
  y_key <- set_names(y_in[vars$y$key], names(vars$x$key))

  args <- join_cast_common(x_key, y_key, vars)
  x_key <- args$x
  y_key <- args$y

  condition <- by$condition
  filter <- by$filter

  # We always want to retain all of the matches. We never experience a Cartesian
  # explosion because `nrow(x) == nrow(out)` is an invariant of `nest_join()`,
  # and the whole point of `nest_join()` is to nest all of the matches for that
  # row of `x` (#6392).
  multiple <- "all"

  # Will be set to `"none"` in `join_rows()`. Because we can't have a Cartesian
  # explosion, we don't care about many-to-many relationships.
  relationship <- NULL

  rows <- join_rows(
    x_key = x_key,
    y_key = y_key,
    type = "nest",
    na_matches = na_matches,
    condition = condition,
    filter = filter,
    cross = cross,
    multiple = multiple,
    unmatched = unmatched,
    relationship = relationship,
    user_env = caller_env()
  )

  y_loc <- vec_split(rows$y, rows$x)$val

  out <- set_names(x_in[vars$x$out], names(vars$x$out))

  # Modify all columns in one step so that we only need to re-group once
  new_cols <- vec_cast(out[names(x_key)], x_key)

  y_out <- set_names(y_in[vars$y$out], names(vars$y$out))
  y_out <- map(y_loc, vec_slice, x = y_out)
  y_out <- map(y_out, dplyr_reconstruct, template = y)
  new_cols[[name]] <- y_out

  out <- dplyr_col_modify(out, new_cols)
  dplyr_reconstruct(out, x)
}

duckplyr_nest_join <- function(x, y, by = NULL, copy = FALSE, keep = NULL, name = NULL, ...) {
  if (is.null(name)) {
    name <- as_label(enexpr(y))
  } else {
    check_string(name)
  }

  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- nest_join(x, y, by, copy, keep, name, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

oo_force <- function() {
  if (dplyr_mode) {
    return(TRUE)
  }

  if (Sys.getenv("DUCKPLYR_OUTPUT_ORDER") == "TRUE") {
    return(TRUE)
  }

  return(FALSE)
}

oo_prep <- function(
    rel,
    colname = "___row_number",
    ...,
    extra_cols_pre = character(),
    extra_cols_post = character(),
    force = oo_force()) {
  check_dots_empty0(...)

  if (!force) {
    return(rel)
  }

  names <- rel_names(rel)

  if (colname %in% names) {
    cli::cli_abort("Can't use column {.var {colname}} already present in rel for order preservation")
  }

  proj_exprs <- imap(set_names(names), relexpr_reference, rel = NULL)
  proj_exprs <- c(
    proj_exprs,
    if (length(extra_cols_pre)) map(extra_cols_pre, relexpr_constant, val = NA_integer_),
    list(relexpr_window(
      relexpr_function("row_number", list()),
      partitions = list(),
      alias = colname
    )),
    if (length(extra_cols_post)) map(extra_cols_post, relexpr_constant, val = NA_integer_),
    NULL
  )

  rel_project(rel, unname(proj_exprs))
}

oo_restore <- function(rel, colname = "___row_number", column_rels = list(NULL)) {
  rel <- oo_restore_order(rel, colname, column_rels)
  oo_restore_cols(rel, colname)
}

oo_restore_order <- function(rel, colname = "___row_number", column_rels = list(NULL), force = oo_force()) {
  if (!force) {
    return(rel)
  }

  order_exprs <- map2(colname, column_rels, relexpr_reference)
  rel_order(rel, order_exprs)
}

oo_restore_cols <- function(rel, colname = "___row_number", extra = NULL, force = oo_force()) {
  if (!force) {
    if (!is.null(extra)) {
      names <- setdiff(rel_names(rel), extra)
      proj_exprs <- imap(set_names(names), relexpr_reference, rel = NULL)
      rel <- rel_project(rel, unname(proj_exprs))
    }

    return(rel)
  }

  names <- setdiff(rel_names(rel), c(colname, extra))
  proj_exprs <- imap(set_names(names), relexpr_reference, rel = NULL)

  rel_project(rel, unname(proj_exprs))
}

exprs_from_loc <- function(.data, loc) {
  nexprs_from_loc(names(.data), loc)
}

nexprs_from_loc <- function(names, loc) {
  stopifnot(is.integer(loc))
  map2(names[loc], names(loc), ~ relexpr_reference(.x, alias = .y))
}

nexprs <- function(names) {
  map(names, ~ relexpr_reference(.x, alias = .x))
}

exprs_project <- function(rel, exprs, .data) {
  out_rel <- rel_project(rel, exprs)
  out <- rel_to_df(out_rel)
  dplyr_reconstruct(out, .data)
}

# Generated by 02-duckplyr_df-methods.R
#' @export
pull.data.frame <- function(.data, var = -1, name = NULL, ...) {
  # dplyr implementation
  my_var <- tidyselect::vars_pull(names(.data), !!enquo(var))
  my_name <- enquo(name)
  if (!quo_is_null(my_name)) {
    my_name <- tidyselect::vars_pull(names(.data), !!my_name)
    my_var <- c(my_name, my_var)
  }

  loc <- set_names(match(my_var, names(.data)), my_var)

  exprs <- exprs_from_loc(.data, loc)

  rel_try(list(name = "pull", .data = .data),
    "Can't use relational with zero-column result set." = (length(exprs) == 0),
    {
      rel <- duckdb_rel_from_df(.data)
      out_rel <- rel_project(rel, exprs)
      out <- rel_to_df(out_rel)
      out <- tibble::deframe(out)
      return(out)
    }
  )

  # dplyr forward
  pull <- pull_data_frame
  out <- pull(.data, {{ var }}, {{ name }}, ...)
  return(out)

  # dplyr implementation
  var <- tidyselect::vars_pull(names(.data), !!enquo(var))
  name <- enquo(name)
  if (quo_is_null(name)) {
    return(.data[[var]])
  }
  name <- tidyselect::vars_pull(names(.data), !!name)
  set_names(.data[[var]], nm = .data[[name]])
}

duckplyr_pull <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- pull(.data, ...)
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
reframe.data.frame <- function(.data, ..., .by = NULL) {
  # Our implementation
  rel_try(NULL,
    "No relational implementation for reframe()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  reframe <- reframe_data_frame
  out <- reframe(.data, ..., .by = {{ .by }})
  return(out)

  # dplyr implementation
  by <- compute_by({{ .by }}, .data, by_arg = ".by", data_arg = ".data")

  cols <- summarise_cols(.data, dplyr_quosures(...), by, "reframe")
  out <- summarise_build(by, cols)

  if (!is_tibble(.data)) {
    # The `by` group data we build from is always a tibble,
    # so we have to manually downcast as needed
    out <- as.data.frame(out)
  }

  out
}

duckplyr_reframe <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- reframe(.data, ...)
  out
}

rel_from_df <- function(df) {
  # FIXME: make generic
  stopifnot(is.data.frame(df))
  new_relational(list(df), class = "relational_df")
}

#' @export
rel_to_df.relational_df <- function(rel, ...) {
  rel[[1L]]
}

#' @export
rel_filter.relational_df <- function(rel, exprs, ...) {}

#' @export
rel_project.relational_df <- function(rel, exprs, ...) {}

#' @export
rel_aggregate.relational_df <- function(rel, groups, aggregates, ...) {}

#' @export
rel_order.relational_df <- function(rel, orders, ...) {}

#' @export
rel_join.relational_df <- function(left, right, conds, ...) {}

#' @export
rel_limit.relational_df <- function(rel, n, ...) {}

#' @export
rel_distinct.relational_df <- function(rel, ...) {}

#' @export
rel_set_intersect.relational_df <- function(rel_a, rel_b, ...) {}

#' @export
rel_set_diff.relational_df <- function(rel_a, rel_b, ...) {}

#' @export
rel_set_symdiff.relational_df <- function(rel_a, rel_b, ...) {}

#' @export
rel_union_all.relational_df <- function(rel_a, rel_b, ...) {}


#' @export
rel_explain.relational_df <- function(rel, ...) {}

#' @export
rel_alias.relational_df <- function(rel, ...) {}

#' @export
rel_set_alias.relational_df <- function(rel, alias, ...) {}

#' @export
rel_names.relational_df <- function(rel, ...) {}

# To be moved to duckdb

# singleton DuckDB instance since we need only one really
# we need a finalizer to disconnect on exit otherwise we get a warning
default_duckdb_connection <- new.env(parent = emptyenv())
get_default_duckdb_connection <- function() {
  if (!exists("con", default_duckdb_connection)) {
    default_duckdb_connection$con <- create_default_duckdb_connection()

    reg.finalizer(default_duckdb_connection, onexit = TRUE, function(e) {
      DBI::dbDisconnect(e$con, shutdown = TRUE)
    })
  }
  default_duckdb_connection$con
}

duckplyr_macros <- c(
  # https://github.com/duckdb/duckdb-r/pull/156
  "___null" = "() AS CAST(NULL AS BOOLEAN)",
  #
  "<" = '(x, y) AS (x < y)',
  "<=" = '(x, y) AS (x <= y)',
  ">" = '(x, y) AS (x > y)',
  ">=" = '(x, y) AS (x >= y)',
  "==" = '(x, y) AS (x == y)',
  "!=" = '(x, y) AS (x != y)',
  #
  "___divide" = "(x, y) AS CASE WHEN y = 0 THEN CASE WHEN x = 0 THEN CAST('NaN' AS double) WHEN x > 0 THEN CAST('+Infinity' AS double) ELSE CAST('-Infinity' AS double) END ELSE CAST(x AS double) / y END",
  #
  "is.na" = "(x) AS (x IS NULL OR isnan(x))",
  "n" = "() AS CAST(COUNT(*) AS int32)",
  #
  "___log10" = "(x) AS CASE WHEN x < 0 THEN CAST('NaN' AS double) WHEN x = 0 THEN CAST('-Inf' AS double) ELSE log10(x) END",
  "___log" = "(x) AS CASE WHEN x < 0 THEN CAST('NaN' AS double) WHEN x = 0 THEN CAST('-Inf' AS double) ELSE ln(x) END",
  # TPCH

  # https://github.com/duckdb/duckdb/discussions/8599
  # "as.Date" = '(x) AS strptime(x, \'%Y-%m-%d\')',

  "grepl" = "(pattern, x) AS (CASE WHEN x IS NULL THEN FALSE ELSE regexp_matches(x, pattern) END)",
  "if_else" = "(test, yes, no) AS (CASE WHEN test IS NULL THEN NULL ELSE CASE WHEN test THEN yes ELSE no END END)",
  "|" = "(x, y) AS (x OR y)",
  "&" = "(x, y) AS (x AND y)",
  "!" = "(x) AS (NOT x)",
  "any" = "(x) AS (bool_or(x))",
  "n_distinct" = "(x) AS (COUNT(DISTINCT x))",
  #
  "wday" = "(x) AS CAST(weekday(CAST (x AS DATE)) + 1 AS int32)",
  #
  "___eq_na_matches_na" = "(x, y) AS (x IS NOT DISTINCT FROM y)",
  "___coalesce" = "(x, y) AS COALESCE(x, y)",
  #
  # FIXME: Need a better way?
  "suppressWarnings" = "(x) AS (x)",
  #
  NULL
)

create_default_duckdb_connection <- function() {
  drv <- duckdb::duckdb()
  con <- DBI::dbConnect(drv)

  # DBI::dbExecute(con, "set memory_limit='1GB'")
  DBI::dbExecute(con, paste0("pragma temp_directory='", tempdir(), "'"))

  duckdb$rapi_load_rfuns(drv@database_ref)

  for (i in seq_along(duckplyr_macros)) {
    sql <- paste0('CREATE MACRO "', names(duckplyr_macros)[[i]], '"', duckplyr_macros[[i]])
    DBI::dbExecute(con, sql)
  }

  con
}

duckdb_rel_from_df <- function(df) {
  # FIXME: make generic
  stopifnot(is.data.frame(df))

  rel <- duckdb$rel_from_altrep_df(df, strict = FALSE, allow_materialized = FALSE)
  if (!is.null(rel)) {
    # Once we're here, we know it's an ALTREP data frame
    # We don't get here if it's already materialized

    rel_names <- duckdb$rapi_rel_names(rel)
    if (!identical(rel_names, names(df))) {
      # This can happen when column names change for an existing relational data frame
      exprs <- nexprs_from_loc(rel_names, set_names(seq_along(df), names(df)))
      rel <- rel_project.duckdb_relation(rel, exprs)
    }
    return(rel)
  }

  if (!is_duckplyr_df(df)) {
    df <- as_duckplyr_df(df)
  }

  out <- check_df_for_rel(df)

  meta_rel_register_df(out, df)

  out

  # Causes protection errors
  # duckdb$rel_from_df(get_default_duckdb_connection(), df)
}

# FIXME: This should be duckdb's responsibility
check_df_for_rel <- function(df) {
  rni <- .row_names_info(df, 0L)
  if (is.character(rni)) {
    cli::cli_abort("Need data frame without row names to convert to relational, got character row names.")
  }
  if (length(rni) != 0) {
    if (length(rni) != 2L || !is.na(rni[[1]])) {
      cli::cli_abort("Need data frame without row names to convert to relational, got numeric row names.")
    }
  }

  for (i in seq_along(df)) {
    col <- .subset2(df, i)
    if (!is.null(names(col))) {
      cli::cli_abort("Can't convert named vectors to relational. Affected column: {.var {names(df)[[i]]}}.")
    }
    if (!is.null(dim(col))) {
      cli::cli_abort("Can't convert arrays or matrices to relational. Affected column: {.var {names(df)[[i]]}}.")
    }
    if (isS4(col)) {
      cli::cli_abort("Can't convert S4 columns to relational. Affected column: {.var {names(df)[[i]]}}.")
    }

    # Factors: https://github.com/duckdb/duckdb/issues/8561

    # When adding new classes, make sure to adapt the first test in test-relational-duckdb.R

    col_class <- class(col)
    if (length(col_class) == 1) {
      valid <- col_class %in% c("logical", "integer", "numeric", "character", "Date", "difftime")
    } else if (length(col_class) == 2) {
      valid <- identical(col_class, c("POSIXct", "POSIXt")) || identical(col_class, c("hms", "difftime"))
    } else {
      valid <- FALSE
    }
    if (!valid) {
      cli::cli_abort("Can't convert columns of class {.cls {col_class}} to relational. Affected column: {.var {names(df)[[i]]}}.")
    }
  }

  # FIXME: For some reason, it's important to create an alias here
  con <- get_default_duckdb_connection()

  # FIXME: For some other reason, it seems crucial to assign the result to a
  # variable before returning it
  experimental <- (Sys.getenv("DUCKPLYR_EXPERIMENTAL") == "TRUE")
  out <- duckdb$rel_from_df(con, df, experimental = experimental)

  roundtrip <- duckdb$rapi_rel_to_altrep(out)
  if (Sys.getenv("DUCKPLYR_CHECK_ROUNDTRIP") == "TRUE") {
    rlang::with_options(duckdb.materialize_message = FALSE, {
      for (i in seq_along(df)) {
        if (!identical(df[[i]], roundtrip[[i]])) {
          cli::cli_abort("Imperfect roundtrip. Affected column: {.var {names(df)[[i]]}}.")
        }
      }
    })
  } else {
    for (i in seq_along(df)) {
      df_attrib <- attributes(df[[i]])
      roundtrip_attrib <- attributes(roundtrip[[i]])
      if (!identical(df_attrib, roundtrip_attrib)) {
        cli::cli_abort("Attributes are lost during conversion. Affected column: {.var {names(df)[[i]]}}.")
      }
      # Always check roundtrip for timestamp columns
      # duckdb uses microsecond precision only, this is in some cases
      # less than R does
      if (inherits(df[[i]], "POSIXct")) {
        if (!identical(df[[i]], roundtrip[[i]])) {
          cli::cli_abort("Imperfect roundtrip. Affected column: {.var {names(df)[[i]]}}.")
        }
      }
    }
  }

  out
}

# https://github.com/r-lib/vctrs/issues/1956
vec_ptype_safe <- function(x) {
  if (inherits(x, "Date")) {
    return(new_date())
  }

  exec(structure, vec_ptype(unclass(x)), !!!attributes(x))
}

#' @export
rel_to_df.duckdb_relation <- function(rel, ...) {
  if (anyDuplicated(tolower(names(rel)))) {
    cli::cli_abort("Column names are case-insensitive in duckdb, fallback required.")
  }

  duckdb$rel_to_altrep(rel)
}

#' @export
rel_filter.duckdb_relation <- function(rel, exprs, ...) {
  duckdb_exprs <- to_duckdb_exprs(exprs)
  out <- duckdb$rel_filter(rel, duckdb_exprs)

  meta_rel_register(out, expr(duckdb$rel_filter(
    !!meta_rel_get(rel)$name,
    list(!!!to_duckdb_exprs_meta(exprs))
  )))

  out
}

#' @export
rel_project.duckdb_relation <- function(rel, exprs, ...) {
  duckdb_exprs <- to_duckdb_exprs(exprs)

  out <- duckdb$rel_project(rel, duckdb_exprs)

  meta_rel_register(out, expr(duckdb$rel_project(
    !!meta_rel_get(rel)$name,
    list(!!!to_duckdb_exprs_meta(exprs))
  )))

  out
}

#' @export
rel_aggregate.duckdb_relation <- function(rel, groups, aggregates, ...) {
  duckdb_groups <- to_duckdb_exprs(groups)
  duckdb_aggregates <- to_duckdb_exprs(aggregates)

  out <- duckdb$rel_aggregate(
    rel,
    groups = duckdb_groups,
    aggregates = duckdb_aggregates
  )

  meta_rel_register(out, expr(duckdb$rel_aggregate(
    !!meta_rel_get(rel)$name,
    groups = list(!!!to_duckdb_exprs_meta(groups)),
    aggregates = list(!!!to_duckdb_exprs_meta(aggregates))
  )))

  out
}

#' @export
rel_order.duckdb_relation <- function(rel, orders, ascending = NULL, ...) {
  duckdb_orders <- to_duckdb_exprs(orders)

  out <- duckdb$rel_order(rel, duckdb_orders, ascending)

  meta_rel_register(out, expr(duckdb$rel_order(
    !!meta_rel_get(rel)$name,
    list(!!!to_duckdb_exprs_meta(orders))
  )))

  out
}

#' @export
rel_join.duckdb_relation <- function(left, right, conds, join, join_ref_type, ...) {
  duckdb_conds <- to_duckdb_exprs(conds)
  if (join == "full") {
    join <- "outer"
  }

  if (join_ref_type == "regular") {
    # Compatibility with older duckdb versions
    out <- duckdb$rel_join(left, right, duckdb_conds, join)

    meta_rel_register(out, expr(duckdb$rel_join(
      !!meta_rel_get(left)$name,
      !!meta_rel_get(right)$name,
      list(!!!to_duckdb_exprs_meta(conds)),
      !!join
    )))
  } else {
    out <- duckdb$rel_join(left, right, duckdb_conds, join, join_ref_type)

    meta_rel_register(out, expr(duckdb$rel_join(
      !!meta_rel_get(left)$name,
      !!meta_rel_get(right)$name,
      list(!!!to_duckdb_exprs_meta(conds)),
      !!join,
      !!join_ref_type
    )))
  }

  out
}

#' @export
rel_limit.duckdb_relation <- function(rel, n, ...) {
  out <- duckdb$rel_limit(rel, n)

  meta_rel_register(out, expr(duckdb$rel_limit(
    !!meta_rel_get(rel)$name,
    !!n
  )))

  out
}

#' @export
rel_distinct.duckdb_relation <- function(rel, ...) {
  out <- duckdb$rel_distinct(rel)

  meta_rel_register(out, expr(duckdb$rel_distinct(
    !!meta_rel_get(rel)$name
  )))

  out
}

#' @export
rel_set_intersect.duckdb_relation <- function(rel_a, rel_b, ...) {
  out <- duckdb$rel_set_intersect(rel_a, rel_b)

  meta_rel_register(out, expr(duckdb$rel_set_intersect(
    !!meta_rel_get(rel_a)$name,
    !!meta_rel_get(rel_b)$name
  )))

  out
}

#' @export
rel_set_diff.duckdb_relation <- function(rel_a, rel_b, ...) {
  out <- duckdb$rel_set_diff(rel_a, rel_b)

  meta_rel_register(out, expr(duckdb$rel_set_diff(
    !!meta_rel_get(rel_a)$name,
    !!meta_rel_get(rel_b)$name
  )))

  out
}

#' @export
rel_set_symdiff.duckdb_relation <- function(rel_a, rel_b, ...) {
  out <- duckdb$rel_set_symdiff(rel_a, rel_b)

  meta_rel_register(out, expr(duckdb$rel_set_symdiff(
    !!meta_rel_get(rel_a)$name,
    !!meta_rel_get(rel_b)$name
  )))

  out
}

#' @export
rel_union_all.duckdb_relation <- function(rel_a, rel_b, ...) {
  out <- duckdb$rel_union_all(rel_a, rel_b)

  meta_rel_register(out, expr(duckdb$rel_union_all(
    !!meta_rel_get(rel_a)$name,
    !!meta_rel_get(rel_b)$name
  )))

  out
}

#' @export
rel_explain.duckdb_relation <- function(rel, ...) {
  duckdb$rel_explain(rel)
}

#' @export
rel_alias.duckdb_relation <- function(rel, ...) {}

#' @export
rel_set_alias.duckdb_relation <- function(rel, alias, ...) {
  out <- duckdb$rel_set_alias(rel, alias)

  meta_rel_register(out, expr(duckdb$rel_set_alias(
    !!meta_rel_get(rel)$name,
    !!alias
  )))

  out
}

#' @export
rel_names.duckdb_relation <- function(rel, ...) {
  duckdb$rapi_rel_names(rel)
}

to_duckdb_exprs <- function(exprs) {
  lapply(exprs, to_duckdb_expr)
}

to_duckdb_expr <- function(x) {
  switch(class(x)[[1]],
    relational_relexpr_reference = {
      out <- duckdb$expr_reference(x$name, if (is.null(x$rel)) "" else x$rel)
      if (!is.null(x$alias)) {
        duckdb$expr_set_alias(out, x$alias)
      }
      out
    },
    relational_relexpr_function = {
      out <- duckdb$expr_function(x$name, to_duckdb_exprs(x$args))
      if (!is.null(x$alias)) {
        duckdb$expr_set_alias(out, x$alias)
      }
      out
    },
    relational_relexpr_window = {
      out <- duckdb$expr_window(
        to_duckdb_expr(x$expr),
        to_duckdb_exprs(x$partitions),
        to_duckdb_exprs(x$order_bys),
        offset_expr = to_duckdb_expr(x$offset_expr),
        default_expr = to_duckdb_expr(x$default_expr)
      )
      if (!is.null(x$alias)) {
        duckdb$expr_set_alias(out, x$alias)
      }
      out
    },
    relational_relexpr_constant = {
      # FIXME: Should be duckdb's responsibility
      # Example: https://github.com/dschafer/activatr/issues/18
      check_df_for_rel(tibble(constant = x$val))

      if ("experimental" %in% names(formals(duckdb$expr_constant))) {
        experimental <- (Sys.getenv("DUCKPLYR_EXPERIMENTAL") == "TRUE")
        out <- duckdb$expr_constant(x$val, experimental = experimental)
      } else {
        out <- duckdb$expr_constant(x$val)
      }
      if (!is.null(x$alias)) {
        duckdb$expr_set_alias(out, x$alias)
      }
      out
    },
    NULL = NULL,
    cli::cli_abort("Unknown expr class: {.cls {class(x)}}")
  )
}

to_duckdb_exprs_meta <- function(exprs) {
  lapply(exprs, to_duckdb_expr_meta)
}

to_duckdb_expr_meta <- function(x) {
  switch(class(x)[[1]],
    relational_relexpr_reference = {
      args <- list(x$name)
      if (!is.null(x$rel)) {
        args <- c(args, meta_rel_get(x$rel)$name)
      }
      out <- expr(duckdb$expr_reference(!!!args))
      if (!is.null(x$alias)) {
        out <- expr({
          tmp_expr <- !!out
          duckdb$expr_set_alias(tmp_expr, !!x$alias)
          tmp_expr
        })
      }
      out
    },
    relational_relexpr_function = {
      meta_macro_register(x$name)
      out <- expr(duckdb$expr_function(!!x$name, list(!!!to_duckdb_exprs_meta(x$args))))
      if (!is.null(x$alias)) {
        out <- expr({
          tmp_expr <- !!out
          duckdb$expr_set_alias(tmp_expr, !!x$alias)
          tmp_expr
        })
      }
      out
    },
    relational_relexpr_window = {
      out <- expr(duckdb$expr_window(
        !!to_duckdb_expr_meta(x$expr),
        list(!!!to_duckdb_exprs_meta(x$partitions)),
        list(!!!to_duckdb_exprs_meta(x$order_bys)),
        offset_expr = !!to_duckdb_expr_meta(x$offset_expr),
        default_expr = !!to_duckdb_expr_meta(x$default_expr)
      ))
      if (!is.null(x$alias)) {
        out <- expr({
          tmp_expr <- !!out
          duckdb$expr_set_alias(tmp_expr, !!x$alias)
          tmp_expr
        })
      }
      out
    },
    relational_relexpr_constant = {
      out <- expr(
        # FIXME: always pass experimental flag once it's merged
        if ("experimental" %in% names(formals(duckdb$expr_constant))) {
          # experimental is set at the top,
          # the sym() gymnastics are to satisfy R CMD check
          duckdb$expr_constant(!!x$val, experimental = !!sym("experimental"))
        } else {
          duckdb$expr_constant(!!x$val)
        }
      )

      if (!is.null(x$alias)) {
        out <- expr({
          tmp_expr <- !!out
          duckdb$expr_set_alias(tmp_expr, !!x$alias)
          tmp_expr
        })
      }
      out
    },
    NULL = expr(NULL),
    cli::cli_abort("Unknown expr class: {.cls {class(x)}}")
  )
}

#' Relational expressions
#'
#' @description
#' These functions provide a backend-agnostic way to construct expression trees
#' built of column references, constants, and functions.
#' All subexpressions in an expression tree can have an alias.
#'
#' `new_relexpr()` constructs an object of class `"relational_relexpr"`.
#' It is used by the higher-level constructors,
#' users should rarely need to call it directly.
#'
#' @param x An object.
#' @param class Classes added in front of the `"relational_relexpr"` base class.
#'
#' @name new_relexpr
#' @return an object of class `"relational_relexpr"`
#' @export
#' @examples
#' relexpr_set_alias(
#'   alias = "my_predicate",
#'   relexpr_function(
#'     "<",
#'     list(
#'       relexpr_reference("my_number"),
#'       relexpr_constant(42)
#'     )
#'   )
#' )
new_relexpr <- function(x, class = NULL) {
  structure(x, class = unique(c(class, "relational_relexpr"), fromLast = TRUE))
}

#' relexpr_reference
#'
#' `relexpr_reference()` constructs a reference to a column.
#'
#' @param name The name of the column or function to reference.
#' @param rel The name of the relation to reference.
#' @param alias An alias for the new expression.
#' @rdname new_relexpr
#' @return an object of class `"relational_relexpr"`
#' @export
relexpr_reference <- function(name, rel = NULL, alias = NULL) {
  stopifnot(is_string(name))
  stopifnot(is.null(rel) || inherits(rel, "duckdb_relation"))
  stopifnot(is.null(alias) || is_string(alias))
  new_relexpr(list(name = name, rel = rel, alias = alias), class = "relational_relexpr_reference")
}

#' relexpr_constant
#'
#' `relexpr_constant()` wraps a constant value.
#'
#' @param val The value to use in the constant expression.
#' @rdname new_relexpr
#' @return an object of class `"relational_relexpr"`
#' @export
relexpr_constant <- function(val, alias = NULL) {
  stopifnot(length(val) == 1)
  stopifnot(is.null(alias) || is_string(alias))
  new_relexpr(list(val = val, alias = alias), class = "relational_relexpr_constant")
}

#' relexpr_function
#'
#' `relexpr_function()` applies a function.
#' The arguments to this function are a list of other expression objects.
#'
#' @param args Function arguments, a list of `expr` objects.
#' @rdname new_relexpr
#' @return an object of class `"relational_relexpr"`
#' @export
relexpr_function <- function(name, args, alias = NULL) {
  stopifnot(is_string(name))
  stopifnot(is.list(args))
  stopifnot(is.null(alias) || is_string(alias))
  new_relexpr(list(name = name, args = args, alias = alias), class = "relational_relexpr_function")
}

#' relexpr_window
#'
#' `relexpr_window()` applies a function over a window,
#' similarly to the SQL `OVER` clause.
#'
#' @param partitions Partitions, a list of `expr` objects.
#' @param order_bys which variables to order results by (list).
#' @param offset_expr offset relational expression.
#' @param default_expr default relational expression.
#' @rdname new_relexpr
#' @export
relexpr_window <- function(
    expr,
    partitions,
    order_bys = list(),
    offset_expr = NULL,
    default_expr = NULL,
    alias = NULL) {
  stopifnot(inherits(expr, "relational_relexpr"))
  stopifnot(is.list(partitions))
  stopifnot(is.list(order_bys))
  stopifnot(is.null(offset_expr) || inherits(offset_expr, "relational_relexpr"))
  stopifnot(is.null(default_expr) || inherits(default_expr, "relational_relexpr"))
  stopifnot(is.null(alias) || is_string(alias))
  new_relexpr(
    list(
      expr = expr,
      partitions = partitions,
      order_bys = order_bys,
      offset_expr = offset_expr,
      default_expr = default_expr,
      alias = alias
    ),
    class = "relational_relexpr_window"
  )
}

#' relexpr_set_alias
#'
#' `relexpr_set_alias()` assigns an alias to an expression.
#'
#' @param expr An `expr` object.
#' @rdname new_relexpr
#' @return an object of class `"relational_relexpr"`
#' @export
relexpr_set_alias <- function(expr, alias = NULL) {
  stopifnot(inherits(expr, "relational_relexpr"))
  stopifnot(is.null(alias) || is_string(alias))
  expr$alias <- alias
  expr
}

#' @export
print.relational_relexpr <- function(x, ...) {
  utils::str(x)
  invisible(x)
}

rel_stats_env <- new.env(parent = emptyenv(), size = 937L)

rel_stats_clean <- function() {
  rm(list = ls(rel_stats_env, all.names = TRUE), pos = rel_stats_env)
}

rel_stats_get <- function() {
  arrange(tibble::enframe(unlist(as.list(rel_stats_env)), "fun", "count"), desc(count))
}

#' Relational implementer's interface
#'
#' @description
#' The constructor and generics described here define a class
#' that helps separating dplyr's user interface from the actual underlying operations.
#' In the longer term, this will help packages that implement the dplyr interface
#' (such as \pkg{dbplyr}, \pkg{dtplyr}, \pkg{arrow} and similar)
#' to focus on the core details of their functionality,
#' rather than on the intricacies of dplyr's user interface.
#'
#' `new_relational()` constructs an object of class `"relational"`.
#' Users are encouraged to provide the `class` argument.
#' The typical use case will be to create a wrapper function.
#'
#' @param ... Passed on to [structure()].
#' @param class Classes added in front of the `"relational"` base class.
#'
#' @return
#' - `new_relational()` returns a new relational object.
#' - `rel_to_df()` returns a data frame.
#' - `rel_names()` returns a character vector.
#' - All other generics return a modified relational object.
#' @name new_relational
#' @export
#' @examples
#' new_dfrel <- function(x) {
#'   stopifnot(is.data.frame(x))
#'   new_relational(list(x), class = "dfrel")
#' }
#' mtcars_rel <- new_dfrel(mtcars[1:5, 1:4])
new_relational <- function(..., class = NULL) {
  structure(..., class = unique(c(class, "relational"), fromLast = TRUE))
}

#' rel_to_df()
#'
#' `rel_to_df()` extracts a data frame representation from a relational object,
#' to be used by [dplyr::collect()].
#'
#' @param rel,rel_a,rel_b,left,right A relational object.
#' @param ... Reserved for future extensions, must be empty.
#' @rdname new_relational
#' @export
#' @examples
#'
#' rel_to_df.dfrel <- function(rel, ...) {
#'   unclass(rel)[[1]]
#' }
#' rel_to_df(mtcars_rel)
rel_to_df <- function(rel, ...) {
  rel_stats_env$rel_to_df <- (rel_stats_env$rel_to_df %||% 0L) + 1L
  UseMethod("rel_to_df")
}

#' rel_filter
#'
#' `rel_filter()` keeps rows that match a predicate,
#'  to be used by [dplyr::filter()].
#'
#' @param exprs A list of `"relational_relexpr"` objects to filter by,
#'   created by [new_relexpr()].
#' @rdname new_relational
#' @export
#' @examples
#'
#' rel_filter.dfrel <- function(rel, exprs, ...) {
#'   df <- unclass(rel)[[1]]
#'
#'   # A real implementation would evaluate the predicates defined
#'   # by the exprs argument
#'   new_dfrel(df[seq_len(min(3, nrow(df))), ])
#' }
#'
#' rel_filter(
#'   mtcars_rel,
#'   list(
#'     relexpr_function(
#'       "gt",
#'       list(relexpr_reference("cyl"), relexpr_constant("6"))
#'     )
#'   )
#' )
rel_filter <- function(rel, exprs, ...) {
  rel_stats_env$rel_filter <- (rel_stats_env$rel_filter %||% 0L) + 1L
  UseMethod("rel_filter")
}

#' rel_project
#'
#' `rel_project()` selects columns or creates new columns,
#' to be used by [dplyr::select()], [dplyr::rename()],
#' [dplyr::mutate()], [dplyr::relocate()], and others.
#'
#' @rdname new_relational
#' @export
#' @examples
#'
#' rel_project.dfrel <- function(rel, exprs, ...) {
#'   df <- unclass(rel)[[1]]
#'
#'   # A real implementation would evaluate the expressions defined
#'   # by the exprs argument
#'   new_dfrel(df[seq_len(min(3, ncol(df)))])
#' }
#'
#' rel_project(
#'   mtcars_rel,
#'   list(relexpr_reference("cyl"), relexpr_reference("disp"))
#' )
rel_project <- function(rel, exprs, ...) {
  rel_stats_env$rel_project <- (rel_stats_env$rel_project %||% 0L) + 1L
  UseMethod("rel_project")
}

#' rel_aggregate
#'
#' `rel_aggregate()` combines several rows into one,
#' to be used by [dplyr::summarize()].
#'
#' @param groups A list of expressions to group by.
#' @param aggregates A list of expressions with aggregates to compute.
#' @rdname new_relational
#' @export
rel_aggregate <- function(rel, groups, aggregates, ...) {
  rel_stats_env$rel_aggregate <- (rel_stats_env$rel_aggregate %||% 0L) + 1L
  UseMethod("rel_aggregate")
}

#' rel_order
#'
#' `rel_order()` reorders rows by columns or expressions,
#' to be used by [dplyr::arrange()].
#'
#' @param orders A list of expressions to order by.
#' @param ascending A logical vector describing the sort order.
#' @rdname new_relational
#' @export
#' @examples
#'
#' rel_order.dfrel <- function(rel, exprs, ...) {
#'   df <- unclass(rel)[[1]]
#'
#'   # A real implementation would evaluate the expressions defined
#'   # by the exprs argument
#'   new_dfrel(df[order(df[[1]]), ])
#' }
#'
#' rel_order(
#'   mtcars_rel,
#'   list(relexpr_reference("mpg"))
#' )
rel_order <- function(rel, orders, ascending, ...) {
  rel_stats_env$rel_order <- (rel_stats_env$rel_order %||% 0L) + 1L
  UseMethod("rel_order")
}

#' rel_join
#'
#' `rel_join()` joins or merges two tables,
#' to be used by [dplyr::left_join()], [dplyr::right_join()],
#' [dplyr::inner_join()], [dplyr::full_join()], [dplyr::cross_join()],
#' [dplyr::semi_join()], and [dplyr::anti_join()].
#'
#' @param conds A list of expressions to use for the join.
#' @param join The type of join.
#' @param join_ref_type The ref type of join.
#' @rdname new_relational
#' @export
#' @examplesIf requireNamespace("dplyr", quietly = TRUE)
#' rel_join.dfrel <- function(left, right, conds, join, ...) {
#'   left_df <- unclass(left)[[1]]
#'   right_df <- unclass(right)[[1]]
#'
#'   # A real implementation would evaluate the expressions
#'   # defined by the conds argument,
#'   # use different join types based on the join argument,
#'   # and implement the join itself instead of relaying to left_join().
#'   new_dfrel(dplyr::left_join(left_df, right_df))
#' }
#'
#' rel_join(new_dfrel(data.frame(mpg = 21)), mtcars_rel)
rel_join <- function(left,
                     right,
                     conds,
                     join = c("inner", "left", "right", "outer", "cross", "semi", "anti"),
                     join_ref_type = c("regular", "natural", "cross", "positional", "asof"),
                     ...) {
  rel_stats_env$rel_join <- (rel_stats_env$rel_join %||% 0L) + 1L
  UseMethod("rel_join")
}

#' rel_limit
#'
#' `rel_limit()` limits the number of rows in a table,
#' to be used by [utils::head()].
#'
#' @param n The number of rows.
#' @rdname new_relational
#' @export
#' @examples
#'
#' rel_limit.dfrel <- function(rel, n, ...) {
#'   df <- unclass(rel)[[1]]
#'
#'   new_dfrel(df[seq_len(n), ])
#' }
#'
#' rel_limit(mtcars_rel, 3)
rel_limit <- function(rel, n, ...) {
  rel_stats_env$rel_limit <- (rel_stats_env$rel_limit %||% 0L) + 1L
  UseMethod("rel_limit")
}

#' rel_distinct()
#'
#' `rel_distinct()` only keeps the distinct rows in a table,
#' to be used by [dplyr::distinct()].
#'
#' @rdname new_relational
#' @export
#' @examples
#'
#' rel_distinct.dfrel <- function(rel, ...) {
#'   df <- unclass(rel)[[1]]
#'
#'   new_dfrel(df[!duplicated(df), ])
#' }
#'
#' rel_distinct(new_dfrel(mtcars[1:3, 1:4]))
rel_distinct <- function(rel, ...) {
  rel_stats_env$rel_distinct <- (rel_stats_env$rel_distinct %||% 0L) + 1L
  UseMethod("rel_distinct")
}

#' rel_set_intersect()
#'
#' `rel_set_intersect()` returns rows present in both tables,
#' to be used by [intersect()].
#'
#' @rdname new_relational
#' @export
rel_set_intersect <- function(rel_a, rel_b, ...) {
  rel_stats_env$rel_set_intersect <- (rel_stats_env$rel_set_intersect %||% 0L) + 1L
  UseMethod("rel_set_intersect")
}

#' rel_set_diff()
#'
#' `rel_set_diff()` returns rows present in any of both tables,
#' to be used by [setdiff()].
#'
#' @rdname new_relational
#' @export
rel_set_diff <- function(rel_a, rel_b, ...) {
  rel_stats_env$rel_set_diff <- (rel_stats_env$rel_set_diff %||% 0L) + 1L
  UseMethod("rel_set_diff")
}

#' rel_set_symdiff()
#'
#' `rel_set_symdiff()` returns rows present in any of both tables,
#' to be used by [dplyr::symdiff()].
#'
#' @rdname new_relational
#' @export
rel_set_symdiff <- function(rel_a, rel_b, ...) {
  rel_stats_env$rel_set_symdiff <- (rel_stats_env$rel_set_symdiff %||% 0L) + 1L
  UseMethod("rel_set_symdiff")
}

#' rel_union_all()
#'
#' `rel_union_all()` returns rows present in any of both tables,
#' to be used by [dplyr::union_all()].
#'
#' @rdname new_relational
#' @export
rel_union_all <- function(rel_a, rel_b, ...) {
  rel_stats_env$rel_union_all <- (rel_stats_env$rel_union_all %||% 0L) + 1L
  UseMethod("rel_union_all")
}

#' rel_explain
#'
#' `rel_explain()` prints an explanation of the plan
#' executed by the relational object.
#'
#' @rdname new_relational
#' @export
rel_explain <- function(rel, ...) {
  rel_stats_env$rel_explain <- (rel_stats_env$rel_explain %||% 0L) + 1L
  UseMethod("rel_explain")
}

#' rel_alias
#'
#' `rel_alias()` returns the alias name for a relational object.
#'
#' @rdname new_relational
#' @export
rel_alias <- function(rel, ...) {
  rel_stats_env$rel_alias <- (rel_stats_env$rel_alias %||% 0L) + 1L
  UseMethod("rel_alias")
}

#' rel_set_alias
#'
#' `rel_set_alias()` sets the alias name for a relational object.
#'
#' @rdname new_relational
#' @param alias the new alias
#' @export
rel_set_alias <- function(rel, alias, ...) {
  rel_stats_env$rel_set_alias <- (rel_stats_env$rel_set_alias %||% 0L) + 1L
  UseMethod("rel_set_alias")
}

#' rel_names()
#'
#' `rel_names()` returns the column names as character vector,
#' to be used by [colnames()].
#'
#' @rdname new_relational
#' @export
#' @examples
#'
#' rel_names.dfrel <- function(rel, ...) {
#'   df <- unclass(rel)[[1]]
#'
#'   names(df)
#' }
#'
#' rel_names(mtcars_rel)
rel_names <- function(rel, ...) {
  rel_stats_env$rel_names <- (rel_stats_env$rel_names %||% 0L) + 1L
  UseMethod("rel_names")
}

rel_try <- function(call, rel, ...) {
  call_name <- as.character(sys.call(-1)[[1]])

  if (!is.null(call$name)) {
    meta_call_start(call$name)
    withr::defer(meta_call_end())
  }

  # Avoid error when called via dplyr:::filter.data.frame() (in yamlet)
  if (length(call_name) == 1 && !(call_name %in% stats$calls)) {
    stats$calls <- c(stats$calls, call_name)
  }

  stats$attempts <- stats$attempts + 1L

  if (Sys.getenv("DUCKPLYR_TELEMETRY_PREP_TEST") == "TRUE") {
    force(call)
  }

  if (Sys.getenv("DUCKPLYR_TELEMETRY_TEST") == "TRUE") {
    force(call)
    json <- call_to_json(
      error_cnd(message = paste0("Error in ", call$name)),
      call
    )
    cli::cli_abort("{call$name}: {json}")
  }

  if (Sys.getenv("DUCKPLYR_FALLBACK_FORCE") == "TRUE") {
    stats$fallback <- stats$fallback + 1L
    return()
  }

  dots <- list(...)
  for (i in seq_along(dots)) {
    if (isTRUE(dots[[i]])) {
      stats$fallback <- stats$fallback + 1L
      if (!dplyr_mode) {
        message <- names(dots)[[i]]
        if (message != "-") {
          tel_collect(message, call)
        }

        if (Sys.getenv("DUCKPLYR_FALLBACK_INFO") == "TRUE") {
          inform(message = c("Requested fallback for relational:", i = message))
        }
        if (Sys.getenv("DUCKPLYR_FORCE") == "TRUE") {
          cli::cli_abort("Fallback not available with {.envvar DUCKPLYR_FORCE}.")
        }
      }

      return()
    }
  }

  if (Sys.getenv("DUCKPLYR_FORCE") == "TRUE") {
    return(rel)
  }

  out <- rlang::try_fetch(rel, error = identity)
  if (inherits(out, "error")) {
    tel_collect(out, call)

    # FIXME: enable always
    if (Sys.getenv("DUCKPLYR_FALLBACK_INFO") == "TRUE") {
      rlang::cnd_signal(rlang::message_cnd(message = "Error processing with relational.", parent = out))
    }
    stats$fallback <- stats$fallback + 1L
    return()
  }

  # Never reached due to return() in code
  cli::cli_abort("Must use a return() in rel_try().")
}

rel_translate_dots <- function(dots, data) {
  if (is.null(names(dots))) {
    map(dots, rel_translate, data)
  } else {
    imap(dots, rel_translate, data = data)
  }
}

# Currently does not support referring to names created during the `summarise()` call.
# Also has specific support for `across()`.
rel_translate_dots_summarise <- function(dots, data) {
  stopifnot(
    !is.null(names(dots))
  )

  out <- reduce(seq_along(dots), .init = NULL, function(.x, .y) {
    current_names <- c(names(data), .x$new)

    dot <- dots[[.y]]
    expanded <- duckplyr_expand_across(current_names, dot)

    if (is.null(expanded)) {
      new <- names(dots)[[.y]]
      translation <- list(rel_translate(dots[[.y]], alias = new, data, names_forbidden = .x$new))
    } else {
      new <- names(expanded)
      translation <- imap(expanded, function(expr, name) rel_translate(expr, alias = name, data, names_forbidden = .x$new))
    }

    list(
      new = c(.x$new, new),
      translation = c(.x$translation, translation)
    )
  })
  out$translation
}

new_failing_mask <- function(names_data) {
  env <- new_environment()
  walk(names_data, ~ env_bind_lazy(env, !!.x := stop("Can't access data in this context")))
  new_data_mask(env)
}

# Generated by 02-duckplyr_df-methods.R
#' @export
relocate.data.frame <- function(.data, ..., .before = NULL, .after = NULL) {
  loc <- eval_relocate(
    expr = expr(c(...)),
    data = .data,
    before = enquo(.before),
    after = enquo(.after),
    before_arg = ".before",
    after_arg = ".after"
  )

  exprs <- exprs_from_loc(.data, loc)

  # Ensure `relocate()` appears in call stack
  rel_try(list(name = "relocate", x = .data, args = list(dots = enquos(...), .before = enquo(.before), .after = enquo(.after))),
    "Can't use relational with zero-column result set." = (length(exprs) == 0),
    {
      rel <- duckdb_rel_from_df(.data)
      out <- exprs_project(rel, exprs, .data)
      return(out)
    }
  )

  # dplyr forward
  relocate <- relocate_data_frame
  out <- relocate(.data, ..., .before = {{ .before }}, .after = {{ .after }})
  return(out)

  # dplyr implementation
  loc <- eval_relocate(
    expr = expr(c(...)),
    data = .data,
    before = enquo(.before),
    after = enquo(.after),
    before_arg = ".before",
    after_arg = ".after"
  )

  out <- dplyr_col_select(.data, loc)
  out <- set_names(out, names(loc))

  out
}

duckplyr_relocate <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- relocate(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
rename.data.frame <- function(.data, ...) {
  loc <- tidyselect::eval_rename(expr(c(...)), .data)
  dupes <- duplicated(loc, fromLast = TRUE)
  loc <- loc[!dupes]

  # eval_rename() only returns changes
  proj <- rlang::set_names(seq_along(.data), names(.data))
  names(proj)[loc] <- names(loc)

  exprs <- exprs_from_loc(.data, proj)

  rel_try(list(name = "rename", x = .data, args = list(dots = enquos(...))),
    "Can't use relational with zero-column result set." = (length(exprs) == 0),
    {
      rel <- duckdb_rel_from_df(.data)
      out <- exprs_project(rel, exprs, .data)
      return(out)
    }
  )

  # dplyr forward
  rename <- rename_data_frame
  out <- rename(.data, ...)
  return(out)

  # dplyr implementation
  loc <- tidyselect::eval_rename(expr(c(...)), .data)
  # eval_rename() only returns changes
  names <- names(.data)
  names[loc] <- names(loc)

  set_names(.data, names)
}

duckplyr_rename <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- rename(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
rename_with.data.frame <- function(.data, .fn, .cols = everything(), ...) {
  # Our implementation
  rel_try(NULL,
    "No relational implementation for rename_with()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  rename_with <- rename_with_data_frame
  out <- rename_with(.data, .fn, {{ .cols }}, ...)
  return(out)

  # dplyr implementation
  .fn <- as_function(.fn)
  cols <- tidyselect::eval_select(enquo(.cols), .data, allow_rename = FALSE)

  names <- names(.data)

  sel <- vec_slice(names, cols)
  new <- .fn(sel, ...)

  if (!is_character(new)) {
    cli::cli_abort(
      "{.arg .fn} must return a character vector, not {.obj_type_friendly {new}}."
    )
  }
  if (length(new) != length(sel)) {
    cli::cli_abort(
      "{.arg .fn} must return a vector of length {length(sel)}, not {length(new)}."
    )
  }

  names <- vec_assign(names, cols, new)
  names <- vec_as_names(names, repair = "check_unique")

  set_names(.data, names)
}

duckplyr_rename_with <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- rename_with(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
right_join.data.frame <- function(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ..., keep = NULL, na_matches = c("na", "never"), multiple = "all", unmatched = "drop", relationship = NULL) {
  check_dots_empty0(...)
  error_call <- caller_env()
  y <- auto_copy(x, y, copy = copy)

  # Our implementation
  rel_try(list(name = "right_join", x = x, y = y, args = list(by = if (!is.null(by) && !is_cross_by(by)) as_join_by(by), copy = copy, keep = keep, na_matches = na_matches, multiple = multiple, unmatched = unmatched, relationship = relationship)),
    "No implicit cross joins for right_join()" = is_cross_by(by),
    {
      out <- rel_join_impl(x, y, by, "right", na_matches, suffix, keep, error_call)
      return(out)
    }
  )

  # dplyr forward
  right_join <- right_join_data_frame
  out <- right_join(x, y, by, copy = FALSE, suffix, ..., keep = keep, na_matches = na_matches, multiple = multiple, unmatched = unmatched, relationship = relationship)
  return(out)

  # dplyr implementation
  check_dots_empty0(...)
  y <- auto_copy(x, y, copy = copy)
  join_mutate(
    x = x,
    y = y,
    by = by,
    type = "right",
    suffix = suffix,
    na_matches = na_matches,
    keep = keep,
    multiple = multiple,
    unmatched = unmatched,
    relationship = relationship,
    user_env = caller_env()
  )
}

duckplyr_right_join <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- right_join(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
rows_append.data.frame <- function(x, y, ..., copy = FALSE, in_place = FALSE) {
  # Our implementation
  rel_try(NULL,
    "No relational implementation for rows_append()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  rows_append <- rows_append_data_frame
  out <- rows_append(x, y, ..., copy = copy, in_place = in_place)
  return(out)

  # dplyr implementation
  check_dots_empty()
  rows_df_in_place(in_place)

  y <- auto_copy(x, y, copy = copy)

  rows_check_x_contains_y(x, y)
  y <- rows_cast_y(y, x)

  rows_bind(x, y)
}

duckplyr_rows_append <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- rows_append(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
rows_delete.data.frame <- function(x, y, by = NULL, ..., unmatched = c("error", "ignore"), copy = FALSE, in_place = FALSE) {
  # Our implementation
  rel_try(NULL,
    "No relational implementation for rows_delete()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  rows_delete <- rows_delete_data_frame
  out <- rows_delete(x, y, by, ..., unmatched = unmatched, copy = copy, in_place = in_place)
  return(out)

  # dplyr implementation
  check_dots_empty()
  rows_df_in_place(in_place)

  y <- auto_copy(x, y, copy = copy)

  by <- rows_check_by(by, y)

  rows_check_contains_by(x, by, "x")
  rows_check_contains_by(y, by, "y")

  x_key <- dplyr_col_select(x, by)
  y_key <- dplyr_col_select(y, by)

  args <- vec_cast_common(x = x_key, y = y_key)
  x_key <- args$x
  y_key <- args$y

  keep <- rows_check_y_unmatched(x_key, y_key, unmatched)

  if (!is.null(keep)) {
    y_key <- dplyr_row_slice(y_key, keep)
  }

  extra <- setdiff(names(y), names(y_key))
  if (!is_empty(extra)) {
    message <- glue("Ignoring extra `y` columns: ", commas(tick_if_needed(extra)))
    inform(message, class = c("dplyr_message_delete_extra_cols", "dplyr_message"))
  }

  loc <- vec_match(x_key, y_key)
  unmatched <- is.na(loc)

  x_loc <- which(unmatched)

  dplyr_row_slice(x, x_loc)
}

duckplyr_rows_delete <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- rows_delete(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
rows_insert.data.frame <- function(x, y, by = NULL, ..., conflict = c("error", "ignore"), copy = FALSE, in_place = FALSE) {
  # Our implementation
  rel_try(NULL,
    "No relational implementation for rows_insert()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  rows_insert <- rows_insert_data_frame
  out <- rows_insert(x, y, by, ..., conflict = conflict, copy = copy, in_place = in_place)
  return(out)

  # dplyr implementation
  check_dots_empty()
  rows_df_in_place(in_place)

  y <- auto_copy(x, y, copy = copy)

  by <- rows_check_by(by, y)

  rows_check_x_contains_y(x, y)
  rows_check_contains_by(x, by, "x")
  rows_check_contains_by(y, by, "y")

  y <- rows_cast_y(y, x)

  x_key <- dplyr_col_select(x, by)
  y_key <- dplyr_col_select(y, by)

  keep <- rows_check_y_conflict(x_key, y_key, conflict)

  if (!is.null(keep)) {
    y <- dplyr_row_slice(y, keep)
  }

  rows_bind(x, y)
}

duckplyr_rows_insert <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- rows_insert(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
rows_patch.data.frame <- function(x, y, by = NULL, ..., unmatched = c("error", "ignore"), copy = FALSE, in_place = FALSE) {
  # Our implementation
  rel_try(NULL,
    "No relational implementation for rows_patch()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  rows_patch <- rows_patch_data_frame
  out <- rows_patch(x, y, by, ..., unmatched = unmatched, copy = copy, in_place = in_place)
  return(out)

  # dplyr implementation
  check_dots_empty()
  rows_df_in_place(in_place)

  y <- auto_copy(x, y, copy = copy)

  by <- rows_check_by(by, y)

  rows_check_x_contains_y(x, y)
  rows_check_contains_by(x, by, "x")
  rows_check_contains_by(y, by, "y")

  x_key <- dplyr_col_select(x, by)
  y_key <- dplyr_col_select(y, by)

  rows_check_unique(y_key, "y")

  args <- vec_cast_common(x = x_key, y = y_key)
  x_key <- args$x
  y_key <- args$y

  values_names <- setdiff(names(y), names(y_key))

  x_values <- dplyr_col_select(x, values_names)
  y_values <- dplyr_col_select(y, values_names)
  y_values <- rows_cast_y(y_values, x_values)

  keep <- rows_check_y_unmatched(x_key, y_key, unmatched)

  if (!is.null(keep)) {
    y_key <- dplyr_row_slice(y_key, keep)
    y_values <- dplyr_row_slice(y_values, keep)
  }

  loc <- vec_match(x_key, y_key)
  match <- !is.na(loc)

  y_loc <- loc[match]
  x_loc <- which(match)

  x_slice <- dplyr_row_slice(x_values, x_loc)
  x_slice <- dplyr_new_list(x_slice)

  y_slice <- dplyr_row_slice(y_values, y_loc)
  y_slice <- dplyr_new_list(y_slice)

  x_patched <- map2(x_slice, y_slice, coalesce)
  x_patched <- new_data_frame(x_patched, n = length(x_loc))

  x_values <- vec_assign(x_values, x_loc, x_patched)
  x_values <- dplyr_new_list(x_values)

  x <- dplyr_col_modify(x, x_values)

  x
}

duckplyr_rows_patch <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- rows_patch(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
rows_update.data.frame <- function(x, y, by = NULL, ..., unmatched = c("error", "ignore"), copy = FALSE, in_place = FALSE) {
  # Our implementation
  rel_try(NULL,
    "No relational implementation for rows_update()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  rows_update <- rows_update_data_frame
  out <- rows_update(x, y, by, ..., unmatched = unmatched, copy = copy, in_place = in_place)
  return(out)

  # dplyr implementation
  check_dots_empty()
  rows_df_in_place(in_place)

  y <- auto_copy(x, y, copy = copy)

  by <- rows_check_by(by, y)

  rows_check_x_contains_y(x, y)
  rows_check_contains_by(x, by, "x")
  rows_check_contains_by(y, by, "y")

  x_key <- dplyr_col_select(x, by)
  y_key <- dplyr_col_select(y, by)

  rows_check_unique(y_key, "y")

  args <- vec_cast_common(x = x_key, y = y_key)
  x_key <- args$x
  y_key <- args$y

  values_names <- setdiff(names(y), names(y_key))

  x_values <- dplyr_col_select(x, values_names)
  y_values <- dplyr_col_select(y, values_names)
  y_values <- rows_cast_y(y_values, x_values)

  keep <- rows_check_y_unmatched(x_key, y_key, unmatched)

  if (!is.null(keep)) {
    y_key <- dplyr_row_slice(y_key, keep)
    y_values <- dplyr_row_slice(y_values, keep)
  }

  loc <- vec_match(x_key, y_key)
  match <- !is.na(loc)

  y_loc <- loc[match]
  x_loc <- which(match)

  y_values <- dplyr_row_slice(y_values, y_loc)

  x_values <- vec_assign(x_values, x_loc, y_values)
  x_values <- dplyr_new_list(x_values)

  x <- dplyr_col_modify(x, x_values)

  x
}

duckplyr_rows_update <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- rows_update(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
rows_upsert.data.frame <- function(x, y, by = NULL, ..., copy = FALSE, in_place = FALSE) {
  # Our implementation
  rel_try(NULL,
    "No relational implementation for rows_upsert()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  rows_upsert <- rows_upsert_data_frame
  out <- rows_upsert(x, y, by, ..., copy = copy, in_place = in_place)
  return(out)

  # dplyr implementation
  check_dots_empty()
  rows_df_in_place(in_place)

  y <- auto_copy(x, y, copy = copy)

  by <- rows_check_by(by, y)

  rows_check_x_contains_y(x, y)
  rows_check_contains_by(x, by, "x")
  rows_check_contains_by(y, by, "y")

  x_key <- dplyr_col_select(x, by)
  y_key <- dplyr_col_select(y, by)

  rows_check_unique(y_key, "y")

  args <- vec_cast_common(x = x_key, y = y_key)
  x_key <- args$x
  y_key <- args$y

  values_names <- setdiff(names(y), names(y_key))

  x_values <- dplyr_col_select(x, values_names)
  y_values <- dplyr_col_select(y, values_names)
  y_values <- rows_cast_y(y_values, x_values)

  loc <- vec_match(x_key, y_key)
  match <- !is.na(loc)

  y_loc <- loc[match]
  x_loc <- which(match)

  # Update
  y_values <- dplyr_row_slice(y_values, y_loc)
  x_values <- vec_assign(x_values, x_loc, y_values)
  x_values <- dplyr_new_list(x_values)

  x <- dplyr_col_modify(x, x_values)

  # Insert
  y_size <- vec_size(y_key)
  y_extra <- dplyr$vec_as_location_invert(y_loc, y_size)

  y <- dplyr_row_slice(y, y_extra)
  y <- rows_cast_y(y, x)

  x <- rows_bind(x, y)

  x
}

duckplyr_rows_upsert <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- rows_upsert(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
rowwise.data.frame <- function(data, ...) {
  # Our implementation
  rel_try(NULL,
    # Always fall back to dplyr
    "No relational implementation for rowwise()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  rowwise <- rowwise_data_frame
  out <- rowwise(data, ...)
  return(out)

  # dplyr implementation
  vars <- tidyselect::eval_select(expr(c(...)), data)
  rowwise_df(data, vars)
}

duckplyr_rowwise <- function(data, ...) {
  try_fetch(
    data <- as_duckplyr_df(data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- rowwise(data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
select.data.frame <- function(.data, ...) {
  force(.data)

  error_call <- dplyr_error_call()

  loc <- tidyselect::eval_select(
    expr(c(...)),
    data = .data,
    error_call = error_call
  )

  exprs <- exprs_from_loc(.data, loc)

  rel_try(list(name = "select", x = .data, args = list(dots = enquos(...))),
    "Can't use relational with zero-column result set." = (length(exprs) == 0),
    {
      rel <- duckdb_rel_from_df(.data)
      out <- exprs_project(rel, exprs, .data)
      return(out)
    }
  )


  # dplyr forward
  select <- select_data_frame
  out <- select(.data, ...)
  return(out)

  # dplyr implementation
  error_call <- dplyr_error_call()

  loc <- tidyselect::eval_select(
    expr(c(...)),
    data = .data,
    error_call = error_call
  )
  loc <- ensure_group_vars(loc, .data, notify = TRUE)

  out <- dplyr_col_select(.data, loc)
  out <- set_names(out, names(loc))

  out
}

duckplyr_select <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- select(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
semi_join.data.frame <- function(x, y, by = NULL, copy = FALSE, ..., na_matches = c("na", "never")) {
  check_dots_empty0(...)
  error_call <- caller_env()
  y <- auto_copy(x, y, copy = copy)

  # https://github.com/duckdb/duckdb/issues/6597
  na_matches <- check_na_matches(na_matches, error_call = error_call)

  # Our implementation
  rel_try(list(name = "semi_join", x = x, y = y, args = list(by = if (!is.null(by) && !is_cross_by(by)) as_join_by(by), copy = copy, na_matches = na_matches)),
    "No restrictions" = FALSE,
    {
      out <- rel_join_impl(x, y, by, "semi", na_matches, error_call = error_call)
      return(out)
    }
  )

  # dplyr forward
  semi_join <- semi_join_data_frame
  out <- semi_join(x, y, by, copy = FALSE, ..., na_matches = na_matches)
  return(out)

  # dplyr implementation
  check_dots_empty0(...)
  y <- auto_copy(x, y, copy = copy)
  join_filter(x, y, by = by, type = "semi", na_matches = na_matches, user_env = caller_env())
}

duckplyr_semi_join <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- semi_join(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
setdiff.data.frame <- function(x, y, ...) {
  # Our implementation
  check_dots_empty()
  check_compatible(x, y)

  x_names <- names(x)
  y_names <- names(y)
  if (identical(x_names, y_names)) {
    # Ensure identical() is very cheap
    y_names <- x_names
  }

  rel_try(list(name = "setdiff", x = x, y = y),
    "No duplicate names" = !identical(x_names, y_names) && anyDuplicated(x_names) && anyDuplicated(y_names),
    "Tables of different width" = length(x_names) != length(y_names),
    "Name mismatch" = !identical(x_names, y_names) && !all(y_names %in% x_names),
    {
      if (oo_force()) {
        delta <- anti_join(x, y, by = x_names)
        out <- distinct(delta)
      } else {
        x_rel <- duckdb_rel_from_df(x)
        y_rel <- duckdb_rel_from_df(y)
        if (!identical(x_names, y_names)) {
          # FIXME: Select by position
          exprs <- nexprs_from_loc(x_names, set_names(seq_along(x_names), x_names))
          y_rel <- rel_project(y_rel, exprs)
        }

        rel <- rel_set_diff(x_rel, y_rel)
        out <- rel_to_df(rel)
        out <- dplyr_reconstruct(out, x)
      }
      return(out)
    }
  )

  # dplyr forward
  setdiff <- setdiff_data_frame
  out <- setdiff(x, y, ...)
  return(out)

  # dplyr implementation
  check_dots_empty()
  check_compatible(x, y)

  out <- vec_set_difference(x, y, error_call = current_env())

  dplyr_reconstruct(out, x)
}

duckplyr_setdiff <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- setdiff(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
setequal.data.frame <- function(x, y, ...) {
  # Our implementation
  rel_try(NULL,
    "No relational implementation for setequal()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  setequal <- setequal_data_frame
  out <- setequal(x, y, ...)
  return(out)

  # dplyr implementation
  check_dots_empty()
  check_compatible(x, y)

  cast <- vec_cast_common(x = x, y = y)
  all(vec_in(cast$x, cast$y)) && all(vec_in(cast$y, cast$x))
}

duckplyr_setequal <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- setequal(x, y, ...)
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
slice.data.frame <- function(.data, ..., .by = NULL, .preserve = FALSE) {
  # Our implementation
  rel_try(NULL,
    "No relational implementation for slice()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  slice <- slice_data_frame
  out <- slice(.data, ..., .by = {{ .by }}, .preserve = .preserve)
  return(out)

  # dplyr implementation
  check_dots_unnamed()

  dots <- enquos(...)

  by <- compute_by(
    by = {{ .by }},
    data = .data,
    by_arg = the$slice_by_arg,
    data_arg = ".data"
  )

  loc <- slice_rows(.data, dots, by)
  dplyr_row_slice(.data, loc, preserve = .preserve)
}

duckplyr_slice <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- slice(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
slice_head.data.frame <- function(.data, ..., n, prop, by = NULL) {
  # Our implementation
  rel_try(NULL,
    "No relational implementation for slice_head()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  slice_head <- slice_head_data_frame
  out <- slice_head(.data, ..., n = n, prop = prop, by = {{ by }})
  return(out)

  # dplyr implementation
  check_dots_empty0(...)

  size <- get_slice_size(n = n, prop = prop)
  idx <- function(n) {
    seq2(1, size(n))
  }

  dplyr_local_error_call()
  dplyr_local_slice_by_arg("by")

  slice(.data, idx(dplyr::n()), .by = {{ by }})
}

duckplyr_slice_head <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- slice_head(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
slice_sample.data.frame <- function(.data, ..., n, prop, by = NULL, weight_by = NULL, replace = FALSE) {
  # Our implementation
  rel_try(NULL,
    "No relational implementation for slice_sample()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  slice_sample <- slice_sample_data_frame
  out <- slice_sample(.data, ..., n = n, prop = prop, by = {{ by }}, weight_by = {{ weight_by }}, replace = replace)
  return(out)

  # dplyr implementation
  check_dots_empty0(...)

  size <- get_slice_size(n = n, prop = prop, allow_outsize = replace)

  dplyr_local_error_call()
  dplyr_local_slice_by_arg("by")

  slice(
    .data,
    .by = {{ by }},
    local({
      weight_by <- {{ weight_by }}

      n <- dplyr::n()
      if (!is.null(weight_by)) {
        vec_check_size(weight_by, size = n)
      }
      sample_int(n, size(n), replace = !!replace, wt = weight_by)
    })
  )
}

duckplyr_slice_sample <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- slice_sample(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
slice_tail.data.frame <- function(.data, ..., n, prop, by = NULL) {
  # Our implementation
  rel_try(NULL,
    "No relational implementation for slice_tail()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  slice_tail <- slice_tail_data_frame
  out <- slice_tail(.data, ..., n = n, prop = prop, by = {{ by }})
  return(out)

  # dplyr implementation
  check_dots_empty0(...)

  size <- get_slice_size(n = n, prop = prop)
  idx <- function(n) {
    seq2(n - size(n) + 1, n)
  }

  dplyr_local_error_call()
  dplyr_local_slice_by_arg("by")

  slice(.data, idx(dplyr::n()), .by = {{ by }})
}

duckplyr_slice_tail <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- slice_tail(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

stats <- new_environment(list(attempts = 0L, fallback = 0L, calls = character()))

#' Show stats
#'
#' Prints statistics on how many calls were handled by DuckDB.
#' The output shows the total number of requests in the current session,
#' split by fallbacks to dplyr and requests handled by duckdb.
#'
#' @return Called for its side effect.
#'
#' @export
#' @examples
#' stats_show()
#'
#' tibble(a = 1:3) %>%
#'   as_duckplyr_df() %>%
#'   mutate(b = a + 1)
#'
#' stats_show()
stats_show <- function() {
  writeLines(paste0(
    c("\U0001f6e0", "\U0001f528", "\U0001f986"),
    paste0("\u003A", " "),
    format(c(stats$attempts, stats$fallback, stats$attempts - stats$fallback))
  ))
  calls <- sort(gsub("[.]duckplyr_df", "", stats$calls))
  writeLines(paste(calls, collapse = ", "))
  invisible()
}

# Generated by 02-duckplyr_df-methods.R
utils::globalVariables("___row_number")

#' @export
summarise.data.frame <- function(.data, ..., .by = NULL, .groups = NULL) {
  force(.data)

  by <- eval_select_by(enquo(.by), .data)

  rel_try(list(name = "summarise", x = .data, args = list(dots = enquos(...), by = syms(by), .groups = .groups)),
    'summarize(.groups = "rowwise") not supported' = identical(.groups, "rowwise"),
    {
      rel <- duckdb_rel_from_df(.data)

      dots <- dplyr_quosures(...)
      dots <- fix_auto_name(dots)
      dots <- dots[!duplicated(names(dots), fromLast = TRUE)]

      oo <- (length(by) > 0) && oo_force()
      if (oo) {
        rel <- oo_prep(rel, colname = "___row_number", force = TRUE)
      }

      groups <- lapply(by, relexpr_reference)
      aggregates <- rel_translate_dots_summarise(dots, .data)

      if (oo) {
        aggregates <- c(
          list(rel_translate(
            quo(min(`___row_number`)),
            new_data_frame(list(`___row_number` = integer())),
            alias = "___row_number"
          )),
          aggregates
        )
      }

      out_rel <- rel_aggregate(rel, groups, unname(aggregates))
      # https://github.com/duckdb/duckdb/issues/7095
      if (length(groups) == 0) {
        out_rel <- rel_distinct(out_rel)
      }

      if (oo) {
        out_rel <- oo_restore(out_rel, "___row_number")
      }

      out <- rel_to_df(out_rel)
      # https://github.com/tidyverse/dplyr/pull/6988
      class(out) <- intersect(c("duckplyr_df", "tbl_df", "tbl", "data.frame"), class(.data))

      return(out)
    }
  )

  # dplyr forward
  summarise <- summarise_data_frame
  out <- summarise(.data, ..., .by = {{ .by }}, .groups = .groups)
  # dplyr_reconstruct() is not called here, restoring manually
  if (!identical(.groups, "rowwise")) {
    # https://github.com/tidyverse/dplyr/pull/6988
    class(out) <- intersect(c("duckplyr_df", "tbl_df", "tbl", "data.frame"), class(.data))
  }
  return(out)

  # dplyr implementation
  by <- compute_by({{ .by }}, .data, by_arg = ".by", data_arg = ".data")

  cols <- summarise_cols(.data, dplyr_quosures(...), by, "summarise")
  out <- summarise_build(by, cols)

  if (!cols$all_one) {
    summarise_deprecate_variable_size()
  }

  if (!is_tibble(.data)) {
    # The `by` group data we build from is always a tibble,
    # so we have to manually downcast as needed
    out <- as.data.frame(out)
  }

  if (identical(.groups, "rowwise")) {
    out <- rowwise_df(out, character())
  }

  out
}

duckplyr_summarise <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- summarise(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
symdiff.data.frame <- function(x, y, ...) {
  # Our implementation
  check_dots_empty()
  check_compatible(x, y)

  x_names <- names(x)
  y_names <- names(y)
  if (identical(x_names, y_names)) {
    # Ensure identical() is very cheap
    y_names <- x_names
  }

  rel_try(list(name = "symdiff", x = x, y = y),
    "No duplicate names" = !identical(x_names, y_names) && anyDuplicated(x_names) && anyDuplicated(y_names),
    "Tables of different width" = length(x_names) != length(y_names),
    "Name mismatch" = !identical(x_names, y_names) && !all(y_names %in% x_names),
    {
      if (oo_force()) {
        x_not_y <- anti_join(x, y, by = x_names)
        y_not_x <- anti_join(y, x, by = x_names)
        out <- union(x_not_y, y_not_x)
      } else {
        x_rel <- duckdb_rel_from_df(x)
        y_rel <- duckdb_rel_from_df(y)

        if (!identical(x_names, y_names)) {
          # FIXME: Select by position
          exprs <- nexprs_from_loc(x_names, set_names(seq_along(x_names), x_names))
          y_rel <- rel_project(y_rel, exprs)
        }

        rel <- rel_set_symdiff(x_rel, y_rel)
        out <- rel_to_df(rel)
        out <- dplyr_reconstruct(out, x)
      }
      return(out)
    }
  )

  # dplyr forward
  symdiff <- symdiff_data_frame
  out <- symdiff(x, y, ...)
  return(out)

  # dplyr implementation
  check_dots_empty()
  check_compatible(x, y)

  out <- vec_set_symmetric_difference(x, y, error_call = current_env())

  dplyr_reconstruct(out, x)
}

duckplyr_symdiff <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- symdiff(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Documented in `.github/CONTRIBUTING.md`

rel_find_call <- function(fun, env) {
  name <- as.character(fun)

  if (name[[1]] == "::") {
    # Fully qualified name, no check needed
    return(c(name[[2]], name[[3]]))
  } else if (length(name) != 1) {
    cli::cli_abort("Can't translate function {.code {expr_deparse(fun)}}.")
  }

  # Order from https://docs.google.com/spreadsheets/d/1j3AFOKiAknTGpXU1uSH7JzzscgYjVbUEwmdRHS7268E/edit?gid=769885824#gid=769885824,
  # generated as `expr_result` by 63-gh-detail.R

  pkgs <- switch(name,
    # Handled in a special way, not mentioned here
    # "desc" = c("dplyr", "duckplyr"),
    "==" = "base",
    "/" = "base",
    "$" = "base", # very special, also with constant folding
    "mean" = "base",
    "n" = c("dplyr", "duckplyr"),
    ">" = "base",
    "%in%" = "base",
    "sum" = "base",
    "!" = "base",
    "&" = "base",
    "-" = "base",
    "(" = "base",
    "is.na" = "base",
    # "ifelse" = "base",
    "!=" = "base",
    # "c" = "base",
    "*" = "base",
    "+" = "base",
    "<" = "base",
    # "[" = "base", # won't implement?
    ">=" = "base",
    "n_distinct" = c("dplyr", "duckplyr"),
    "max" = "base",
    "<=" = "base",
    # "as.numeric" = "base",
    "|" = "base",
    # "factor" = "base",
    # "^" = "base",
    "min" = "base",
    # "replace" = "base",
    "grepl" = "base",
    # ":" = "base",
    # "as.character" = "base",
    # "paste" = "base",
    # "round" = "base",
    # "paste0" = "base",
    # "length" = "base",
    # ".data$" = c("dplyr", "duckplyr"), # implemented
    "sd" = "stats",
    # "[[" = "base", # won't implement?
    # "gsub" = "base",
    # "str_detect" = "stringr",
    "median" = "stats",
    # "~" = "base", # won't implement?
    # "unique" = "base", # what's the use case?
    # ".$" = c("dplyr", "duckplyr"), # won't implement?
    # "%>%" = "magrittr", # with the help of magrittr?
    # "as.Date" = "base",
    "as.integer" = "base",
    # "nrow" = "base",
    # "as.factor" = "base",
    # "%<=>%" = "???", # what is this?
    "row_number" = c("dplyr", "duckplyr"),
    # "rev" = "base", # what's the use case?
    # "seq" = "base", # what's the use case?
    # "sqrt" = "base",
    # "abs" = "base",
    "if_else" = c("dplyr", "duckplyr"),
    #
    "any" = "base",
    "suppressWarnings" = "base",
    "lag" = c("dplyr", "duckplyr"),
    "lead" = c("dplyr", "duckplyr"),
    "first" = c("dplyr", "duckplyr"),
    "last" = c("dplyr", "duckplyr"),
    "nth" = c("dplyr", "duckplyr"),
    "log10" = "base",
    "log" = "base",
    "rank" = "base",
    "min_rank" = c("dplyr", "duckplyr"),
    "dense_rank" = c("dplyr", "duckplyr"),
    "percent_rank" = c("dplyr", "duckplyr"),
    "cume_dist" = c("dplyr", "duckplyr"),
    "ntile" = c("dplyr", "duckplyr"),
    "hour" = "lubridate",
    "minute" = "lubridate",
    "second" = "lubridate",
    "wday" = "lubridate",
    "strftime" = "base",
    "abs" = "base",
    "substr" = "base",
    NULL
  )

  if (is.null(pkgs)) {
    cli::cli_abort("No translation for function {.code {name}}.")
  }

  # https://github.com/tidyverse/dplyr/pull/7046
  if (name == "n") {
    return(c("dplyr", "n"))
  }

  fun_val <- get0(as.character(fun), env, mode = "function", inherits = TRUE)

  for (pkg in pkgs) {
    if (identical(fun_val, get(name, envir = asNamespace(pkg)))) {
      return(c(pkg, name))
    }
  }

  if (length(pkgs) == 1) {
    cli::cli_abort("Function {.code {name}} does not map to {.code {pkgs}::{name}}.")
  } else {
    cli::cli_abort("Function {.code {name}} does not map to the corresponding function in {.pkg {pkgs}}.")
  }
}

rel_translate_lang <- function(
  expr,
  do_translate,
  # FIXME: Perform constant folding instead
  names_data,
  env,
  # FIXME: Perform constant folding instead
  partition,
  in_window,
  need_window
) {
  pkg_name <- rel_find_call(expr[[1]], env)
  pkg <- pkg_name[[1]]
  name <- pkg_name[[2]]

  if (!(name %in% c("wday", "strftime", "lag", "lead"))) {
    if (!is.null(names(expr)) && any(names(expr) != "")) {
      # Fix grepl() logic below when allowing matching by argument name
      cli::cli_abort("Can't translate named argument {.code {name}({names(expr)[names(expr) != ''][[1]]} = )}.")
    }
  }

  switch(name,
    "(" = {
      return(do_translate(expr[[2]], in_window = in_window))
    },
    # Hack
    "wday" = {
      if (!is.null(pkg) && pkg != "lubridate") {
        cli::cli_abort("Don't know how to translate {.code {pkg}::{name}}.")
      }
      def <- lubridate::wday
      call <- match.call(def, expr, envir = env)
      args <- as.list(call[-1])
      bad <- !(names(args) %in% c("x"))
      if (any(bad)) {
        cli::cli_abort("{name}({names(args)[which(bad)[[1]]]} = ) not supported")
      }
      if (!is.null(getOption("lubridate.week.start"))) {
        cli::cli_abort('{.code wday()} with {.code option("lubridate.week.start")} not supported')
      }
    },
    "strftime" = {
      def <- strftime
      call <- match.call(def, expr, envir = env)
      args <- as.list(call[-1])
      bad <- !(names(args) %in% c("x", "format"))
      if (any(bad)) {
        cli::cli_abort("{name}({names(args)[which(bad)[[1]]]} = ) not supported")
      }
    },
    "%in%" = {
      values <- eval_tidy(expr[[3]], data = new_failing_mask(names_data), env = env)
      if (length(values) == 0) {
        return(relexpr_constant(FALSE))
      }

      lhs <- do_translate(expr[[2]])

      if (anyNA(values)) {
        has_na <- TRUE
        values <- values[!is.na(values)]
        if (length(values) == 0) {
          return(relexpr_function("is.na", list(lhs)))
        }
      } else {
        has_na <- FALSE
      }

      consts <- map(values, do_translate)
      ops <- map(consts, ~ list(lhs, .x))
      cmp <- map(ops, relexpr_function, name = "r_base::==")
      alt <- reduce(cmp, function(.x, .y) {
        relexpr_function("|", list(.x, .y))
      })
      coalesce <- relexpr_function("___coalesce", list(alt, relexpr_constant(has_na)))
      meta_ext_register()
      return(coalesce)
    },
    "$" = {
      if (expr[[2]] == ".data") {
        return(do_translate(expr[[3]], in_window = in_window))
      } else if (expr[[2]] == ".env") {
        var_name <- as.character(expr[[3]])
        if (exists(var_name, envir = env)) {
          return(do_translate(get(var_name, env), in_window = in_window))
        } else {
          cli::cli_abort("internal: object not found, should also be triggered by the dplyr fallback")
        }
      }
    }
  )

  aliases <- c(
    sd = "stddev",
    first = "first_value",
    last = "last_value",
    nth = "nth_value",
    "/" = "___divide",
    "log10" = "___log10",
    "log" = "___log",
    "as.integer" = "r_base::as.integer",
    "<" = "r_base::<",
    "<=" = "r_base::<=",
    ">" = "r_base::>",
    ">=" = "r_base::>=",
    "==" = "r_base::==",
    "!=" = "r_base::!=",
    NULL
  )

  known_window <- c(
    # Window functions
    "rank", "dense_rank", "percent_rank",
    "row_number", "first", "last", "nth",
    "cume_dist", "lead", "lag", "ntile",

    # Aggregates
    "sum", "mean", "sd", "min", "max", "median",
    #
    NULL
  )

  window <- need_window && (name %in% known_window)

  if (name %in% names(aliases)) {
    name <- aliases[[name]]
    if (grepl("^r_base::", name)) {
      meta_ext_register()
    }
  }
  # name <- aliases[name] %|% name

  order_bys <- list()
  offset_expr <- NULL
  default_expr <- NULL
  if (name %in% c("lag", "lead")) {
    # x, n = 1L, default = NULL, order_by = NULL
    expr <- match.call(lag, expr)

    offset_expr <- relexpr_constant(expr$n %||% 1L)
    expr$n <- NULL

    if (!is.null(expr$default)) {
      default_expr <- do_translate(expr$default, in_window = TRUE)
      expr$default <- NULL
    }

    if (!is.null(expr$order_by)) {
      order_bys <- list(do_translate(expr$order_by, in_window = TRUE))
      expr$order_by <- NULL
    }
  }

  args <- map(as.list(expr[-1]), do_translate, in_window = in_window || window)

  if (name == "grepl") {
    if (!inherits(args[[1]], "relational_relexpr_constant")) {
      cli::cli_abort("Only constant patterns are supported in {.code grepl()}")
    }
  }

  fun <- relexpr_function(name, args)
  if (window) {
    partitions <- map(partition, relexpr_reference)
    fun <- relexpr_window(
      fun,
      partitions,
      order_bys,
      offset_expr = offset_expr,
      default_expr = default_expr
    )

    if (name == "row_number") {
      fun <- relexpr_function("r_base::as.integer", list(fun))
      meta_ext_register()
    }
  }
  fun
}

rel_translate <- function(
    quo, data,
    alias = NULL,
    partition = NULL,
    need_window = FALSE,
    names_data = names(data),
    names_forbidden = NULL) {
  if (is_expression(quo)) {
    expr <- quo
    env <- baseenv()
  } else {
    expr <- quo_get_expr(quo)
    env <- quo_get_env(quo)
  }

  used <- character()

  do_translate <- function(expr, in_window = FALSE, top_level = FALSE) {
    stopifnot(!is_quosure(expr))
    switch(typeof(expr),
      character = ,
      integer = ,
      double = relexpr_constant(expr),
      # https://github.com/duckdb/duckdb-r/pull/156
      logical = if (top_level && length(expr) == 1 && is.na(expr)) relexpr_function("___null", list()) else relexpr_constant(expr),
      #
      symbol = {
        if (as.character(expr) %in% names_forbidden) {
          cli::cli_abort("Can't reuse summary variable {.var {as.character(expr)}}.")
        }
        if (as.character(expr) %in% names_data) {
          ref <- as.character(expr)
          if (!(ref %in% used)) {
            used <<- c(used, ref)
          }
          relexpr_reference(ref)
        } else {
          val <- eval_tidy(expr, env = env)
          relexpr_constant(val)
        }
      },
      #
      language = rel_translate_lang(
        expr,
        do_translate,
        names_data,
        env,
        partition,
        in_window,
        need_window
      ),
      #
      cli::cli_abort("Internal: Unknown type {.val {typeof(expr)}}")
    )
  }

  out <- do_translate(expr, top_level = TRUE)

  if (!is.null(alias) && !identical(alias, "")) {
    out <- relexpr_set_alias(out, alias)
  }

  structure(out, used = used)
}

# Generated by 02-duckplyr_df-methods.R
#' @export
transmute.data.frame <- function(.data, ...) {
  force(.data)

  dots <- check_transmute_args(...)
  dots <- dplyr_quosures(!!!dots)
  dots <- fix_auto_name(dots)

  rel_try(list(name = "transmute", x = .data, args = list(dots = enquos(...))),
    "Can't use relational with zero-column result set." = (length(dots) == 0),
    {
      exprs <- rel_translate_dots(dots, .data)
      rel <- duckdb_rel_from_df(.data)
      out_rel <- rel_project(rel, exprs)
      out <- rel_to_df(out_rel)
      out <- dplyr_reconstruct(out, .data)
      return(out)
    }
  )

  # dplyr forward
  transmute <- transmute_data_frame
  out <- transmute(.data, ...)
  return(out)

  # dplyr implementation
  dots <- check_transmute_args(...)
  dots <- dplyr_quosures(!!!dots)

  # We don't expose `.by` because `transmute()` is superseded
  by <- compute_by(by = NULL, data = .data)

  cols <- mutate_cols(.data, dots, by)

  out <- dplyr_col_modify(.data, cols)

  # Compact out `NULL` columns that got removed.
  # These won't exist in `out`, but we don't want them to look "new".
  # Note that `dplyr_col_modify()` makes it impossible to `NULL` a group column,
  # which we rely on below.
  cols <- compact_null(cols)

  # Retain expression columns in order of their appearance
  cols_expr <- names(cols)

  # Retain untouched group variables up front
  cols_group <- by$names
  cols_group <- setdiff(cols_group, cols_expr)

  cols_retain <- c(cols_group, cols_expr)

  dplyr_col_select(out, cols_retain)
}

duckplyr_transmute <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- transmute(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
ungroup.data.frame <- function(x, ...) {
  # Our implementation
  rel_try(NULL,
    "No relational implementation for ungroup()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  ungroup <- ungroup_data_frame
  out <- ungroup(x, ...)
  return(out)

  # dplyr implementation
  check_dots_empty()
  x
}

duckplyr_ungroup <- function(x, ...) {
  try_fetch(
    x <- as_duckplyr_df(x),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- ungroup(x, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
union.data.frame <- function(x, y, ...) {
  # Our implementation
  check_dots_empty()

  # This is difficult to do manually due to order preservation
  return(distinct(union_all(x, y)))

  # dplyr forward
  union <- union_data_frame
  out <- union(x, y, ...)
  return(out)

  # dplyr implementation
  check_dots_empty()
  check_compatible(x, y)

  out <- vec_set_union(x, y, error_call = current_env())

  dplyr_reconstruct(out, x)
}

duckplyr_union <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- union(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
union_all.data.frame <- function(x, y, ...) {
  # Our implementation
  check_dots_empty()
  check_compatible(x, y)

  x_names <- names(x)
  y_names <- names(y)
  if (identical(x_names, y_names)) {
    # Ensure identical() is very cheap
    y_names <- x_names
  }

  rel_try(list(name = "union_all", x = x, y = y),
    "No duplicate names" = !identical(x_names, y_names) && anyDuplicated(x_names) && anyDuplicated(y_names),
    "Tables of different width" = length(x_names) != length(y_names),
    "Name mismatch" = !identical(x_names, y_names) && !all(y_names %in% x_names),
    {
      x_rel <- duckdb_rel_from_df(x)
      y_rel <- duckdb_rel_from_df(y)
      if (!identical(x_names, y_names)) {
        # FIXME: Select by position
        exprs <- nexprs_from_loc(x_names, set_names(seq_along(x_names), x_names))
        y_rel <- rel_project(y_rel, exprs)
      }

      x_rel <- oo_prep(x_rel, "___row_number_x", extra_cols_post = "___row_number_y")
      y_rel <- oo_prep(y_rel, "___row_number_y", extra_cols_pre = "___row_number_x")

      rel <- rel_union_all(x_rel, y_rel)

      # NULLs sort first in duckdb!
      rel <- oo_restore(rel, c("___row_number_x", "___row_number_y"))

      out <- rel_to_df(rel)
      out <- dplyr_reconstruct(out, x)
      return(out)
    }
  )

  # dplyr forward
  union_all <- union_all_data_frame
  out <- union_all(x, y, ...)
  return(out)

  # dplyr implementation
  check_dots_empty()
  check_compatible(x, y)

  out <- vec_rbind(x, y)
  dplyr_reconstruct(out, x)
}

duckplyr_union_all <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- union_all(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

on_load({
  if (Sys.getenv("DUCKPLYR_METHODS_OVERWRITE") == "TRUE") {
    methods_overwrite()
  }
})

