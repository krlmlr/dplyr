# Generated by 02-duckplyr_df-methods.R
#' @export
add_count.data.frame <- function(x, ..., wt = NULL, sort = FALSE, name = NULL, .drop = deprecated()) {
  # Our implementation
  rel_try(
    "No relational implementation for add_count()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  add_count <- add_count_data_frame
  out <- add_count(x, ..., wt = {{ wt }}, sort = sort, name = name, .drop = .drop)
  return(out)

  # dplyr implementation
  out <- add_count_impl(
    x,
    ...,
    wt = {{ wt }},
    sort = sort,
    name = name,
    .drop = .drop
  )
  dplyr_reconstruct(out, x)
}

duckplyr_add_count <- function(x, ...) {
  try_fetch(
    x <- as_duckplyr_df(x),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- add_count(x, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
anti_join.data.frame <- function(x, y, by = NULL, copy = FALSE, ..., na_matches = c("na", "never")) {
  check_dots_empty0(...)
  error_call <- caller_env()

  # https://github.com/duckdb/duckdb/issues/6597
  na_matches <- check_na_matches(na_matches, error_call = error_call)

  # Our implementation
  rel_try(
    "No relational implementation for anti_join(copy = TRUE)" = copy,
    {
      out <- rel_join_impl(x, y, by, "anti", na_matches, error_call = error_call)
      return(out)
    }
  )

  # dplyr forward
  anti_join <- anti_join_data_frame
  out <- anti_join(x, y, by, copy, ..., na_matches = na_matches)
  return(out)

  # dplyr implementation
  check_dots_empty0(...)
  y <- auto_copy(x, y, copy = copy)
  join_filter(x, y, by = by, type = "anti", na_matches = na_matches, user_env = caller_env())
}

duckplyr_anti_join <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- anti_join(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
arrange.data.frame <- function(.data, ..., .by_group = FALSE, .locale = NULL) {
  force(.data)

  dots <- enquos(...)
  dots <- unname(dots)

  if (.by_group) {
    dots <- c(quos(!!!groups(.data)), dots)
  }

  rel_try(
    ".locale argument not supported" = !is.null(.locale),
    "dplyr.legacy_locale not supported" = isTRUE(getOption("dplyr.legacy_locale")),
    {
      # Translate to df before early exit, so that we can bail out for subclasses
      rel <- duckdb_rel_from_df(.data)
      if (length(dots) == 0) {
        return(.data)
      }
      exprs <- rel_translate_dots(dots, .data)
      out_rel <- rel_order(rel, exprs)
      out <- rel_to_df(out_rel)
      out <- dplyr_reconstruct(out, .data)
      return(out)
    }
  )

  # dplyr forward
  arrange <- arrange_data_frame
  out <- arrange(.data, ..., .by_group = .by_group, .locale = .locale)
  return(out)

  # dplyr implementation
  dots <- enquos(...)

  if (.by_group) {
    dots <- c(quos(!!!groups(.data)), dots)
  }

  loc <- arrange_rows(.data, dots = dots, locale = .locale)
  dplyr_row_slice(.data, loc)
}

duckplyr_arrange <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- arrange(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

#' @export
as_duckplyr_df <- function(.data) {
  if (inherits(.data, "duckplyr_df")) {
    return(.data)
  }

  if (!identical(class(.data), "data.frame") && !identical(class(.data), c("tbl_df", "tbl", "data.frame"))) {
    abort("Must pass a plain data frame or a tibble to `as_duckplyr_df()`.")
  }

  if (is.character(.row_names_info(.data, 0L))) {
    abort("Must pass data frame without row names to `as_duckplyr_df()`.")
  }

  if (anyNA(names(.data)) || any(names(.data) == "")) {
    abort("Missing or empty names not allowed.")
  }

  class(.data) <- c("duckplyr_df", class(.data))
  .data
}

# Generated by 02-duckplyr_df-methods.R
#' @export
auto_copy.data.frame <- function(x, y, copy = FALSE, ...) {
  return(as_duckplyr_df(y))

  # dplyr implementation
  as.data.frame(y)
}

duckplyr_auto_copy <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- auto_copy(x, y, ...)
  out
}

# Generated by 02-duckplyr_df-methods.R
duckplyr_collapse <- function(x, ...) {
  try_fetch(
    x <- as_duckplyr_df(x),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- collapse(x, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
collect.data.frame <- function(x, ...) {
  # Side effect: ALTREP materialization is triggered
  nrow(x)
  x
}

duckplyr_collect <- function(x, ...) {
  try_fetch(
    x <- as_duckplyr_df(x),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- collect(x, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
compute.data.frame <- function(x, ...) {
  # Our implementation
  rel_try(
    "No relational implementation for compute()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  compute <- compute_data_frame
  out <- compute(x, ...)
  return(out)

  # dplyr implementation
  x
}

duckplyr_compute <- function(x, ...) {
  try_fetch(
    x <- as_duckplyr_df(x),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- compute(x, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
count.data.frame <- function(x, ..., wt = NULL, sort = FALSE, name = NULL, .drop = group_by_drop_default(x)) {
  force(x)

  dplyr_local_error_call()

  by <- dplyr_quosures(...)
  by <- fix_auto_name(by)

  by_exprs <- unname(map(by, quo_get_expr))
  is_name <- map_lgl(by_exprs, is_symbol)

  rel_try(
    "count() needs all(is_name)" = !all(is_name),
    "count() only implemented for .drop = TRUE" = !.drop,
    "count() only implemented for sort = FALSE" = sort,
    {
      by_chr <- map_chr(by_exprs, as_string)
      name <- check_n_name(name, by_chr)

      if (name %in% by_chr) {
        abort("Name clash in count()")
      }

      n <- tally_n(x, {{ wt }})

      rel <- duckdb_rel_from_df(x)

      groups <- rel_translate_dots(by, x)
      aggregates <- list(rel_translate(n, x, alias = name))

      out_rel <- rel_aggregate(rel, groups, unname(aggregates))
      if (length(groups) > 0) {
        sort_cols <- nexprs(names(groups))
        out_rel <- rel_order(out_rel, sort_cols)
      }

      out <- rel_to_df(out_rel)
      out <- dplyr_reconstruct(out, x)

      return(out)
    }
  )

  # FIXME: optimize, no need to forward dots
  # out <- count(x_df, !!!quos, wt = {{ wt }}, sort = sort, name = name, .drop = .drop)

  # dplyr forward
  count <- count_data_frame
  out <- count(x, ..., wt = {{ wt }}, sort = sort, name = name, .drop = .drop)
  return(out)

  # dplyr implementation
  dplyr_local_error_call()

  if (!missing(...)) {
    out <- group_by(x, ..., .add = TRUE, .drop = .drop)
  } else {
    out <- x
  }

  out <- tally(out, wt = !!enquo(wt), sort = sort, name = name)

  # Ensure grouping is transient
  out <- dplyr_reconstruct(out, x)

  out
}

duckplyr_count <- function(x, ...) {
  try_fetch(
    x <- as_duckplyr_df(x),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- count(x, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
cross_join.data.frame <- function(x, y, ..., copy = FALSE, suffix = c(".x", ".y")) {
  # Our implementation
  rel_try(
    "No relational implementation for cross_join()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  cross_join <- cross_join_data_frame
  out <- cross_join(x, y, ..., copy = copy, suffix = suffix)
  return(out)

  # dplyr implementation
  check_dots_empty0(...)

  y <- auto_copy(x, y, copy = copy)

  x_names <- tbl_vars(x)
  y_names <- tbl_vars(y)

  # Empty join by with no keys
  by <- new_join_by()

  # Particular value isn't too important, as there are no keys to keep/drop
  keep <- FALSE

  vars <- join_cols(
    x_names = x_names,
    y_names = y_names,
    by = by,
    suffix = suffix,
    keep = keep
  )

  x_in <- as_tibble(x, .name_repair = "minimal")
  y_in <- as_tibble(y, .name_repair = "minimal")

  x_size <- vec_size(x_in)
  y_size <- vec_size(y_in)

  x_out <- set_names(x_in, names(vars$x$out))
  y_out <- set_names(y_in, names(vars$y$out))

  x_out <- vec_rep_each(x_out, times = y_size)
  y_out <- vec_rep(y_out, times = x_size)

  x_out[names(y_out)] <- y_out

  dplyr_reconstruct(x_out, x)
}

duckplyr_cross_join <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- cross_join(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

#' @export
duckdb_from_file <- function(path, table_function, options=list()) {
  # FIXME: For some reason, it's important to create an alias here
  con <- get_default_duckdb_connection()

  out <- duckdb:::rel_from_table_function(
    con,
    table_function,
    list(path),
    options
  )

  meta_rel_register_file(out, path, table_function, options)

  duckdb:::rel_to_altrep(out)
}

#' @export
duckplyr_df_from_file <- function(path, table_function, options=list()) {
  out <- duckdb_from_file(path, table_function, options)
  as_duckplyr_df(out)
}

# Generated by 02-duckplyr_df-methods.R
#' @export
distinct.data.frame <- function(.data, ..., .keep_all = FALSE) {
  # Our implementation
  rel_try(
    {
      dots <- enquos(..., .named = TRUE)
      # FIXME: avoid column duplication in a cleaner way
      dupes <- duplicated(names(dots), fromLast = TRUE)
      dots <- dots[!dupes]

      rel <- duckdb_rel_from_df(.data)

      oo <- .keep_all || oo_force()

      if (oo) {
        # Push row number as separate projection
        rel <- oo_prep(rel, force = TRUE)

        exprs <- rel_translate_dots(dots, .data)
        all_exprs <- NULL
        if (length(exprs) == 0) {
          exprs <- imap(set_names(names(.data)), relexpr_reference, rel = NULL)
          all_exprs <- exprs
        }

        if (.keep_all) {
          proj_exprs <- all_exprs %||% imap(set_names(names(.data)), relexpr_reference, rel = NULL)
        } else {
          proj_exprs <- exprs
        }

        proj_exprs <- c(proj_exprs, list(
          relexpr_reference("___row_number"),
          relexpr_window(
            relexpr_function("row_number", list()),
            partitions = exprs,
            alias = "___row_number_by"
          )
        ))

        rel <- rel_project(rel, unname(proj_exprs))

        expr_filter <- rel_translate(
          quo(`___row_number_by` == 1L),
          names_data = "___row_number_by"
        )
        out_rel <- rel_filter(rel, list(expr_filter))

        out_rel <- oo_restore_order(out_rel, force = TRUE)
        out_rel <- oo_restore_cols(out_rel, extra = "___row_number_by", force = TRUE)
      } else {
        exprs <- rel_translate_dots(dots, .data)
        if (length(exprs) > 0) {
          rel <- rel_project(rel, exprs)
        }
        out_rel <- rel_distinct(rel)
      }

      out <- rel_to_df(out_rel)
      out <- dplyr_reconstruct(out, .data)
      return(out)
    }
  )

  # dplyr forward
  distinct <- distinct_data_frame
  out <- distinct(.data, ..., .keep_all = .keep_all)
  return(out)

  # dplyr implementation
  prep <- distinct_prepare(
    .data,
    vars = enquos(...),
    group_vars = group_vars(.data),
    .keep_all = .keep_all,
    caller_env = caller_env()
  )

  out <- prep$data

  cols <- dplyr_col_select(out, prep$vars)
  loc <- vec_unique_loc(cols)

  out <- dplyr_col_select(out, prep$keep)
  dplyr_row_slice(out, loc)
}

duckplyr_distinct <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- distinct(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
do.data.frame <- function(.data, ...) {
  # Our implementation
  rel_try(
    "No relational implementation for do()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  do <- do_data_frame
  out <- do(.data, ...)
  return(out)

  # dplyr implementation
  args <- enquos(...)
  named <- named_args(args)

  # Create custom data mask with `.` pronoun
  mask <- new_data_mask(new_environment())
  env_bind_do_pronouns(mask, .data)

  if (!named) {
    out <- eval_tidy(args[[1]], mask)
    if (!inherits(out, "data.frame")) {
      msg <- glue("Result must be a data frame, not {fmt_classes(out)}.")
      abort(msg)
    }
  } else {
    out <- map(args, function(arg) list(eval_tidy(arg, mask)))
    names(out) <- names(args)
    out <- tibble::as_tibble(out, .name_repair = "minimal")
  }

  out
}

duckplyr_do <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- do(.data, ...)
  out
}

fix_auto_name <- function(dots) {
  if (is.null(names(dots))) {
    dots <- set_names(dots, "")
  }

  for (i in seq_along(dots)) {
    dot <- dots[[i]]
    if (names(dots)[[i]] == "") {
      quo_data <- attr(dot, "dplyr:::data")
      names(dots)[[i]] <- as_label(quo_data$name)
    }
  }

  dots
}

duckplyr_mutate_keep <- function(out, keep, used, names_new, names_groups) {
  if (keep == "all") {
    return(out)
  }

  names <- names(out)

  names_keep <- switch(keep,
    used = names(used)[used],
    unused = names(used)[!used],
    none = character(),
    abort("Unknown `keep`.", .internal = TRUE)
  )

  names_out <- intersect(names, c(names_new, names_groups, names_keep))

  select(out, !!!names_out)
}

# Generated by 02-duckplyr_df-methods.R
#' @export
dplyr_reconstruct.data.frame <- function(data, template) {
  if (inherits(data, c("grouped_df", "rowwise_df"))) {
    return(data)
  }
  .Call(copy_df_attribs, data, template)
  return(data)

  # dplyr forward
  dplyr_reconstruct <- dplyr_reconstruct_data_frame
  out <- dplyr_reconstruct(data, template)
  return(out)

  # dplyr implementation
  attrs <- attributes(template)
  attrs$names <- names(data)
  attrs$row.names <- .row_names_info(data, type = 0L)

  attributes(data) <- attrs
  data
}

duckplyr_dplyr_reconstruct <- function(data, ...) {
  try_fetch(
    data <- as_duckplyr_df(data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- dplyr_reconstruct(data, ...)
  out
}

#' @importFrom dplyr explain
#' @export
explain.data.frame <- function(x, ...) {
  rel_try({
    rel <- duckdb_rel_from_df(x)
    rel_explain(rel)
    return(invisible())
  })

  writeLines("Can't convert to relational, fallback implementation will be used.")
  invisible()
}

# Generated by 02-duckplyr_df-methods.R
#' @export
filter.data.frame <- function(.data, ..., .by = NULL, .preserve = FALSE) {
  force(.data)

  dots <- dplyr_quosures(...)
  check_filter(dots)

  by <- enquo(.by)

  rel_try(
    "Can't use relational with zero-column result set." = (length(.data) == 0),
    "Can't use relational without filter conditions." = (length(dots) == 0),
    "Can't use relational with grouped operation." = (!quo_is_null(by)), # (length(by$names) > 0),
    {
      exprs <- rel_translate_dots(dots, .data)
      rel <- duckdb_rel_from_df(.data)
      out_rel <- rel_filter(rel, exprs)
      out <- rel_to_df(out_rel)
      out <- dplyr_reconstruct(out, .data)
      return(out)
    }
  )

  # dplyr forward
  filter <- filter_data_frame
  out <- filter(.data, ..., .by = {{ .by }}, .preserve = .preserve)
  return(out)

  # dplyr implementation
  dots <- dplyr_quosures(...)
  check_filter(dots)

  by <- compute_by(
    by = {{ .by }},
    data = .data,
    by_arg = ".by",
    data_arg = ".data"
  )

  loc <- filter_rows(.data, dots, by)
  dplyr_row_slice(.data, loc, preserve = .preserve)
}

duckplyr_filter <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- filter(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
full_join.data.frame <- function(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ..., keep = NULL, na_matches = c("na", "never"), multiple = "all", relationship = NULL) {
  check_dots_empty0(...)
  error_call <- caller_env()

  # Our implementation
  rel_try(
    "No implicit cross joins for full_join()" = is_cross_by(by),
    "No relational implementation for full_join(copy = TRUE)" = copy,
    {
      out <- rel_join_impl(x, y, by, "full", na_matches, suffix, keep, error_call)
      return(out)
    }
  )

  # dplyr forward
  full_join <- full_join_data_frame
  out <- full_join(x, y, by, copy, suffix, ..., keep = keep, na_matches = na_matches, multiple = multiple, relationship = relationship)
  return(out)

  # dplyr implementation
  check_dots_empty0(...)
  y <- auto_copy(x, y, copy = copy)
  join_mutate(
    x = x,
    y = y,
    by = by,
    type = "full",
    suffix = suffix,
    na_matches = na_matches,
    keep = keep,
    multiple = multiple,
    # All keys from both inputs are retained. Erroring never makes sense.
    unmatched = "drop",
    relationship = relationship,
    user_env = caller_env()
  )
}

duckplyr_full_join <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- full_join(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
group_vars.data.frame <- function(x) {
  if (inherits(x, c("grouped_df", "rowwise_df"))) {
    return(group_vars_data_frame(x))
  }

  # Avoid calling group_data()
  character()
}

duckplyr_group_vars <- function(x, ...) {
  try_fetch(
    x <- as_duckplyr_df(x),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- group_vars(x, ...)
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
inner_join.data.frame <- function(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ..., keep = NULL, na_matches = c("na", "never"), multiple = "all", unmatched = "drop", relationship = NULL) {
  check_dots_empty0(...)
  error_call <- caller_env()

  # Our implementation
  rel_try(
    "No implicit cross joins for inner_join()" = is_cross_by(by),
    "No relational implementation for inner_join(copy = TRUE)" = copy,
    {
      out <- rel_join_impl(x, y, by, "inner", na_matches, suffix, keep, error_call)
      return(out)
    }
  )

  # dplyr forward
  inner_join <- inner_join_data_frame
  out <- inner_join(x, y, by, copy, suffix, ..., keep = keep, na_matches = na_matches, multiple = multiple, unmatched = unmatched, relationship = relationship)
  return(out)

  # dplyr implementation
  check_dots_empty0(...)
  y <- auto_copy(x, y, copy = copy)
  join_mutate(
    x = x,
    y = y,
    by = by,
    type = "inner",
    suffix = suffix,
    na_matches = na_matches,
    keep = keep,
    multiple = multiple,
    unmatched = unmatched,
    relationship = relationship,
    user_env = caller_env()
  )
}

duckplyr_inner_join <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- inner_join(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
intersect.data.frame <- function(x, y, ...) {
  # Our implementation
  check_dots_empty()

  x_names <- names(x)
  y_names <- names(y)
  if (identical(x_names, y_names)) {
    # Ensure identical() is very cheap
    y_names <- x_names
  }

  rel_try(
    "No duplicate names" = !identical(x_names, y_names) && anyDuplicated(x_names) && anyDuplicated(y_names),
    "Tables of different width" = length(x_names) != length(y_names),
    "Name mismatch" = !identical(x_names, y_names) && !all(y_names %in% x_names),
    {
      x_rel <- duckdb_rel_from_df(x)
      y_rel <- duckdb_rel_from_df(y)
      if (!identical(x_names, y_names)) {
        # FIXME: Select by position
        exprs <- nexprs_from_loc(x_names, set_names(seq_along(x_names), x_names))
        y_rel <- rel_project(y_rel, exprs)
      }

      rel <- rel_set_intersect(x_rel, y_rel)
      out <- rel_to_df(rel)
      out <- dplyr_reconstruct(out, x)
      return(out)
    }
  )

  # dplyr forward
  intersect <- intersect_data_frame
  out <- intersect(x, y, ...)
  return(out)

  # dplyr implementation
  check_dots_empty()
  check_compatible(x, y)

  out <- vec_set_intersect(x, y, error_call = current_env())

  dplyr_reconstruct(out, x)
}

duckplyr_intersect <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- intersect(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

#' @export
is_duckplyr_df <- function(.data) {
  inherits(.data, "duckplyr_df")
}

rel_join_impl <- function(x, y, by, join, na_matches, suffix, keep, error_call = caller_env()) {
  mutating <- !(join %in% c("semi", "anti"))

  if (mutating) {
    check_keep(keep, error_call = error_call)
  }

  na_matches <- check_na_matches(na_matches, error_call = error_call)

  x_names <- tbl_vars(x)
  y_names <- tbl_vars(y)

  if (is_null(by)) {
    by <- join_by_common(x_names, y_names, error_call = error_call)
  } else {
    by <- as_join_by(by, error_call = error_call)
  }

  x_by <- by$x
  y_by <- by$y
  x_rel <- duckdb_rel_from_df(x)
  x_rel <- rel_set_alias(x_rel, "lhs")
  y_rel <- duckdb_rel_from_df(y)
  y_rel <- rel_set_alias(y_rel, "rhs")

  # Rename if non-unique column names
  if (mutating) {
    if (length(intersect(x_names, y_names)) != 0) {
      x_names_remap <- paste0(x_names, "_x")
      x_by <- paste0(x_by, "_x")
      x_exprs <- exprs_from_loc(x, set_names(seq_along(x_names_remap), x_names_remap))
      x_rel <- rel_project(x_rel, x_exprs)

      y_names_remap <- paste0(y_names, "_y")
      y_by <- paste0(y_by, "_y")
      y_exprs <- exprs_from_loc(y, set_names(seq_along(y_names_remap), y_names_remap))
      y_rel <- rel_project(y_rel, y_exprs)
    } else {
      x_names_remap <- x_names
      y_names_remap <- y_names
    }
  }

  x_rel <- oo_prep(x_rel, "___row_number_x")
  if (mutating) {
    y_rel <- oo_prep(y_rel, "___row_number_y")
  }

  x_by <- map(x_by, relexpr_reference, rel = x_rel)
  y_by <- map(y_by, relexpr_reference, rel = y_rel)

  cond_by <- by$condition

  if (na_matches == "na") {
    cond_by[cond_by == "=="] <- "___eq_na_matches_na"
  }

  conds <- pmap(list(cond_by, x_by, y_by), ~ relexpr_function(..1, list(..2, ..3)))

  if (any(by$filter != "none")) {
    join_ref_type <- "asof"
  } else {
    join_ref_type <- "regular"
  }

  joined <- rel_join(x_rel, y_rel, conds, join, join_ref_type)

  if (mutating) {
    joined <- oo_restore_order(
      joined,
      c("___row_number_x", "___row_number_y"),
      list(x_rel, y_rel)
    )

    vars <- join_cols(
      x_names = x_names,
      y_names = y_names,
      by = by,
      suffix = suffix,
      keep = keep,
      error_call = error_call
    )

    exprs <- c(
      nexprs_from_loc(x_names_remap, vars$x$out),
      nexprs_from_loc(y_names_remap, vars$y$out)
    )

    remap <- (is.null(keep) || is_false(keep))

    if (remap) {
      by_pos <- match(names(vars$x$key), x_names)
      # Only coalesce for equi-joins
      eq_idx <- (by$condition == "==")

      if (join == "right") {
        exprs[by_pos[eq_idx]] <- map2(y_by[eq_idx], names(vars$x$key)[eq_idx], relexpr_set_alias)
      } else {
        exprs[by_pos[eq_idx]] <- pmap(
          list(x_by[eq_idx], y_by[eq_idx], names(vars$x$key)[eq_idx]),
          ~ relexpr_function("___coalesce", list(..1, ..2), alias = ..3)
        )
      }
    }

    out <- rel_project(joined, exprs)
  } else {
    out <- oo_restore(joined, "___row_number_x", list(x_rel))
  } # if (mutating)

  out <- rel_to_df(out)
  out <- dplyr_reconstruct(out, x)

  return(out)
}

# Generated by 02-duckplyr_df-methods.R
#' @export
left_join.data.frame <- function(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ..., keep = NULL, na_matches = c("na", "never"), multiple = "all", unmatched = "drop", relationship = NULL) {
  check_dots_empty0(...)
  error_call <- caller_env()

  # Our implementation
  rel_try(
    "No implicit cross joins for left_join()" = is_cross_by(by),
    "No relational implementation for left_join(copy = TRUE)" = copy,
    {
      out <- rel_join_impl(x, y, by, "left", na_matches, suffix, keep, error_call)
      return(out)
    }
  )

  # dplyr forward
  left_join <- left_join_data_frame
  out <- left_join(x, y, by, copy, suffix, ..., keep = keep, na_matches = na_matches, multiple = multiple, unmatched = unmatched, relationship = relationship)
  return(out)

  # dplyr implementation
  check_dots_empty0(...)
  y <- auto_copy(x, y, copy = copy)
  join_mutate(
    x = x,
    y = y,
    by = by,
    type = "left",
    suffix = suffix,
    na_matches = na_matches,
    keep = keep,
    multiple = multiple,
    unmatched = unmatched,
    relationship = relationship,
    user_env = caller_env()
  )
}

duckplyr_left_join <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- left_join(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
mutate.data.frame <- function(.data, ..., .by = NULL, .keep = c("all", "used", "unused", "none"), .before = NULL, .after = NULL) {
  by_arg <- enquo(.by)
  keep <- arg_match(.keep)

  by_names <- eval_select_by(by_arg, .data)

  # Our implementation
  rel_try(
    {
      rel <- duckdb_rel_from_df(.data)

      if (length(by_names) > 0) {
        rel <- oo_prep(rel)
      }

      dots <- dplyr_quosures(...)
      dots <- fix_auto_name(dots)

      names_used <- character()
      names_new <- character()
      names_out <- rel_names(rel)

      # FIXME: use fewer projections
      for (i in seq_along(dots)) {
        dot <- dots[[i]]

        new <- names(dots)[[i]]

        names_new <- c(names_new, new)

        new_pos <- match(new, names_out, nomatch = length(names_out) + 1L)
        exprs <- imap(set_names(names_out), relexpr_reference, rel = NULL)
        new_expr <- rel_translate(dot, names_data = names_out, alias = new, partition = by_names, need_window = TRUE)
        exprs[[new_pos]] <- new_expr

        rel <- rel_project(rel, unname(exprs))
        names_out[[new_pos]] <- new

        new_names_used <- intersect(attr(new_expr, "used"), names(.data))
        names_used <- c(names_used, setdiff(new_names_used, names_used))
      }

      if (length(by_names) > 0) {
        rel <- oo_restore(rel)
      }

      out <- rel_to_df(rel)

      out <- dplyr_reconstruct(out, .data)

      names_original <- names(.data)

      out <- mutate_relocate(
        out = out,
        before = {{ .before }},
        after = {{ .after }},
        names_original = names_original
      )

      used <- set_names(names(out) %in% names_used, names(out))
      names_groups <- by_names

      out <- duckplyr_mutate_keep(
        out = out,
        keep = keep,
        used = used,
        names_new = names_new,
        names_groups = names_groups
      )

      return(out)
    }
  )

  # dplyr forward
  mutate <- mutate_data_frame
  out <- mutate(.data, ..., .by = {{ .by }}, .keep = .keep, .before = {{ .before }}, .after = {{ .after }})
  return(out)

  # dplyr implementation
  keep <- arg_match0(.keep, values = c("all", "used", "unused", "none"))

  by <- compute_by({{ .by }}, .data, by_arg = ".by", data_arg = ".data")

  cols <- mutate_cols(.data, dplyr_quosures(...), by)
  used <- attr(cols, "used")

  out <- dplyr_col_modify(.data, cols)

  names_original <- names(.data)

  out <- mutate_relocate(
    out = out,
    before = {{ .before }},
    after = {{ .after }},
    names_original = names_original
  )

  names_new <- names(cols)
  names_groups <- by$names

  out <- mutate_keep(
    out = out,
    keep = keep,
    used = used,
    names_new = names_new,
    names_groups = names_groups
  )

  out
}

duckplyr_mutate <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- mutate(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
nest_by.data.frame <- function(.data, ..., .key = "data", .keep = FALSE) {
  # Our implementation
  rel_try(
    "No relational implementation for nest_by()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  nest_by <- nest_by_data_frame
  out <- nest_by(.data, ..., .key = .key, .keep = .keep)
  return(out)

  # dplyr implementation
  .data <- group_by(.data, ...)
  nest_by.grouped_df(.data, .key = .key, .keep = .keep)
}

duckplyr_nest_by <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- nest_by(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
nest_join.data.frame <- function(x, y, by = NULL, copy = FALSE, keep = NULL, name = NULL, ..., na_matches = c("na", "never"), unmatched = "drop") {
  # from dplyr implementation
  check_keep(keep)
  na_matches <- check_na_matches(na_matches)

  if (is.null(name)) {
    name <- as_label(enexpr(y))
  } else {
    check_string(name)
  }

  # Our implementation
  rel_try(
    "No relational implementation for nest_join()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  x_df <- x
  class(x_df) <- setdiff(class(x_df), "duckplyr_df")
  y_df <- y
  class(y_df) <- setdiff(class(y_df), "duckplyr_df")
  nest_join <- nest_join_data_frame
  out <- nest_join(x_df, y_df, by, copy, keep, name, ..., na_matches = na_matches, unmatched = unmatched)
  out <- dplyr_reconstruct(out, x)
  return(out)

  # dplyr implementation
  check_dots_empty0(...)
  check_keep(keep)
  na_matches <- check_na_matches(na_matches)

  if (is.null(name)) {
    name <- as_label(enexpr(y))
  } else {
    check_string(name)
  }

  x_names <- tbl_vars(x)
  y_names <- tbl_vars(y)

  if (is_cross_by(by)) {
    warn_join_cross_by()
    by <- new_join_by()
    cross <- TRUE
  } else {
    cross <- FALSE
  }

  if (is_null(by)) {
    by <- join_by_common(x_names, y_names)
  } else {
    by <- as_join_by(by)
  }

  vars <- join_cols(x_names, y_names, by = by, suffix = c("", ""), keep = keep)
  y <- auto_copy(x, y, copy = copy)

  x_in <- as_tibble(x, .name_repair = "minimal")
  y_in <- as_tibble(y, .name_repair = "minimal")

  x_key <- set_names(x_in[vars$x$key], names(vars$x$key))
  y_key <- set_names(y_in[vars$y$key], names(vars$x$key))

  args <- join_cast_common(x_key, y_key, vars)
  x_key <- args$x
  y_key <- args$y

  condition <- by$condition
  filter <- by$filter

  # We always want to retain all of the matches. We never experience a Cartesian
  # explosion because `nrow(x) == nrow(out)` is an invariant of `nest_join()`,
  # and the whole point of `nest_join()` is to nest all of the matches for that
  # row of `x` (#6392).
  multiple <- "all"

  # Will be set to `"none"` in `join_rows()`. Because we can't have a Cartesian
  # explosion, we don't care about many-to-many relationships.
  relationship <- NULL

  rows <- join_rows(
    x_key = x_key,
    y_key = y_key,
    type = "nest",
    na_matches = na_matches,
    condition = condition,
    filter = filter,
    cross = cross,
    multiple = multiple,
    unmatched = unmatched,
    relationship = relationship,
    user_env = caller_env()
  )

  y_loc <- vec_split(rows$y, rows$x)$val

  out <- set_names(x_in[vars$x$out], names(vars$x$out))

  # Modify all columns in one step so that we only need to re-group once
  new_cols <- vec_cast(out[names(x_key)], x_key)

  y_out <- set_names(y_in[vars$y$out], names(vars$y$out))
  y_out <- map(y_loc, vec_slice, x = y_out)
  y_out <- map(y_out, dplyr_reconstruct, template = y)
  new_cols[[name]] <- y_out

  out <- dplyr_col_modify(out, new_cols)
  dplyr_reconstruct(out, x)
}

duckplyr_nest_join <- function(x, y, by = NULL, copy = FALSE, keep = NULL, name = NULL, ...) {
  if (is.null(name)) {
    name <- as_label(enexpr(y))
  } else {
    check_string(name)
  }

  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- nest_join(x, y, by, copy, keep, name, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

oo_force <- function() {
  if (dplyr_mode) {
    return(TRUE)
  }

  if (Sys.getenv("DUCKPLYR_OUTPUT_ORDER") == "TRUE") {
    return(TRUE)
  }

  return(FALSE)
}

oo_prep <- function(rel, colname = "___row_number", force = oo_force()) {
  if (!force) {
    return(rel)
  }

  names <- rel_names(rel)

  if (colname %in% names) {
    abort("Must use column name not yet present in rel")
  }

  proj_exprs <- imap(set_names(names), relexpr_reference, rel = NULL)
  proj_exprs <- c(proj_exprs, list(relexpr_window(
    relexpr_function("row_number", list()),
    partitions = list(),
    alias = colname
  )))

  rel_project(rel, unname(proj_exprs))
}

oo_restore <- function(rel, colname = "___row_number", column_rels = list(NULL)) {
  rel <- oo_restore_order(rel, colname, column_rels)
  oo_restore_cols(rel, colname)
}

oo_restore_order <- function(rel, colname = "___row_number", column_rels = list(NULL), force = oo_force()) {
  if (!force) {
    return(rel)
  }

  order_exprs <- map2(colname, column_rels, relexpr_reference)
  rel_order(rel, order_exprs)
}

oo_restore_cols <- function(rel, colname = "___row_number", extra = NULL, force = oo_force()) {
  if (!force) {
    if (!is.null(extra)) {
      names <- setdiff(rel_names(rel), extra)
      proj_exprs <- imap(set_names(names), relexpr_reference, rel = NULL)
      rel <- rel_project(rel, unname(proj_exprs))
    }

    return(rel)
  }

  names <- setdiff(rel_names(rel), c(colname, extra))
  proj_exprs <- imap(set_names(names), relexpr_reference, rel = NULL)

  rel_project(rel, unname(proj_exprs))
}

exprs_from_loc <- function(.data, loc) {
  nexprs_from_loc(names(.data), loc)
}

nexprs_from_loc <- function(names, loc) {
  stopifnot(is.integer(loc))
  map2(names[loc], names(loc), ~ relexpr_reference(.x, alias = .y))
}

nexprs <- function(names) {
  map(names, ~ relexpr_reference(.x, alias = .x))
}

exprs_project <- function(rel, exprs, .data) {
  out_rel <- rel_project(rel, exprs)
  out <- rel_to_df(out_rel)
  dplyr_reconstruct(out, .data)
}

# Generated by 02-duckplyr_df-methods.R
#' @export
pull.data.frame <- function(.data, var = -1, name = NULL, ...) {
  # dplyr implementation
  my_var <- tidyselect::vars_pull(names(.data), !!enquo(var))
  my_name <- enquo(name)
  if (!quo_is_null(my_name)) {
    my_name <- tidyselect::vars_pull(names(.data), !!my_name)
    my_var <- c(my_name, my_var)
  }

  loc <- set_names(match(my_var, names(.data)), my_var)

  exprs <- exprs_from_loc(.data, loc)

  rel_try(
    "Can't use relational with zero-column result set." = (length(exprs) == 0),
    {
      rel <- duckdb_rel_from_df(.data)
      out_rel <- rel_project(rel, exprs)
      out <- rel_to_df(out_rel)
      out <- tibble::deframe(out)
      return(out)
    }
  )

  # dplyr forward
  pull <- pull_data_frame
  out <- pull(.data, {{ var }}, {{ name }}, ...)
  return(out)

  # dplyr implementation
  var <- tidyselect::vars_pull(names(.data), !!enquo(var))
  name <- enquo(name)
  if (quo_is_null(name)) {
    return(.data[[var]])
  }
  name <- tidyselect::vars_pull(names(.data), !!name)
  set_names(.data[[var]], nm = .data[[name]])
}

duckplyr_pull <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- pull(.data, ...)
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
reframe.data.frame <- function(.data, ..., .by = NULL) {
  # Our implementation
  rel_try(
    "No relational implementation for reframe()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  reframe <- reframe_data_frame
  out <- reframe(.data, ..., .by = {{ .by }})
  return(out)

  # dplyr implementation
  by <- compute_by({{ .by }}, .data, by_arg = ".by", data_arg = ".data")

  cols <- summarise_cols(.data, dplyr_quosures(...), by, "reframe")
  out <- summarise_build(by, cols)

  if (!is_tibble(.data)) {
    # The `by` group data we build from is always a tibble,
    # so we have to manually downcast as needed
    out <- as.data.frame(out)
  }

  out
}

duckplyr_reframe <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- reframe(.data, ...)
  out
}

#' Data frame relational backend
#'
#' TBD.
#'
#' @param df A data frame.
#' @return A relational object.
#'
#' @export
rel_from_df <- function(df) {
  # FIXME: make generic
  stopifnot(is.data.frame(df))
  new_relational(list(df), class = "relational_df")
}

#' @export
rel_to_df.relational_df <- function(rel, ...) {
  rel[[1L]]
}

#' @export
rel_filter.relational_df <- function(rel, exprs, ...) {
}

#' @export
rel_project.relational_df <- function(rel, exprs, ...) {
}

#' @export
rel_aggregate.relational_df <- function(rel, groups, aggregates, ...) {
}

#' @export
rel_order.relational_df <- function(rel, orders, ...) {
}

#' @export
rel_join.relational_df <- function(left, right, conds, ...) {
}

#' @export
rel_limit.relational_df <- function(rel, n, ...) {
}

#' @export
rel_distinct.relational_df <- function(rel, ...) {
}

#' @export
rel_set_intersect.relational_df <- function(rel_a, rel_b, ...) {
}

#' @export
rel_set_diff.relational_df <- function(rel_a, rel_b, ...) {
}

#' @export
rel_set_symdiff.relational_df <- function(rel_a, rel_b, ...) {
}

#' @export
rel_union_all.relational_df <- function(rel_a, rel_b, ...) {
}


#' @export
rel_tostring.relational_df <- function(rel, ...) {
}

#' @export
rel_explain.relational_df <- function(rel, ...) {
}

#' @export
rel_alias.relational_df <- function(rel, ...) {
}

#' @export
rel_set_alias.relational_df <- function(rel, alias, ...) {
}

#' @export
rel_names.relational_df <- function(rel, ...) {
}

# To be moved to duckdb

# singleton DuckDB instance since we need only one really
# we need a finalizer to disconnect on exit otherwise we get a warning
default_duckdb_connection <- new.env(parent = emptyenv())
get_default_duckdb_connection <- function() {
  if (!exists("con", default_duckdb_connection)) {
    default_duckdb_connection$con <- create_default_duckdb_connection()

    reg.finalizer(default_duckdb_connection, onexit = TRUE, function(e) {
      DBI::dbDisconnect(e$con, shutdown = TRUE)
    })
  }
  default_duckdb_connection$con
}

duckplyr_macros <- c(
  "<" = '(x, y) AS x < y',
  "<=" = '(x, y) AS x <= y',
  ">" = '(x, y) AS x > y',
  ">=" = '(x, y) AS x >= y',
  "!=" = '(x, y) AS x <> y',

  "___divide" = "(x, y) AS CASE WHEN x = 0 AND y = 0 THEN CAST('NaN' AS double) ELSE CAST(x AS double) / y END",

  "is.na" = '(x) AS (x IS NULL)',
  "n" = '() AS CAST(COUNT(*) AS int32)',

  "log10" = '(x) AS log(x)',
  "log" = '(x) AS ln(x)',
  # TPCH

  # https://github.com/duckdb/duckdb/discussions/8599
  # "as.Date" = '(x) AS strptime(x, \'%Y-%m-%d\')',

  "grepl" = '(pattern, x) AS regexp_matches(x, pattern)',
  "as.integer" = '(x) AS CAST(x AS int32)',
  "ifelse" = '(test, yes, no) AS (CASE WHEN test THEN yes ELSE no END)',
  "|" = '(x, y) AS (x OR y)',
  "&" = '(x, y) AS (x AND y)',
  "!" = '(x) AS (NOT x)',
  "any" = '(x) AS (bool_or(x))',
  "desc" = '(x) AS (-x)',
  "n_distinct" = '(x) AS (COUNT(DISTINCT x))',

  "wday" = "(x) AS CAST(weekday(CAST (x AS DATE)) + 1 AS int32)",

  "___eq_na_matches_na" = '(x, y) AS ((x IS NULL AND y IS NULL) OR (x = y))',
  # https://github.com/duckdb/duckdb/issues/8605
  # "___eq_na_matches_na" = '(x, y) AS (x IS DISTINCT FROM y)',
  "___coalesce" = '(x, y) AS COALESCE(x, y)',

  NULL
)

create_default_duckdb_connection <- function() {
  con <- DBI::dbConnect(duckdb::duckdb())

  for (i in seq_along(duckplyr_macros)) {
    sql <- paste0('CREATE MACRO "', names(duckplyr_macros)[[i]], '"', duckplyr_macros[[i]])
    DBI::dbExecute(con, sql)
  }

  duckdb:::rapi_rel_register_functions(con@conn_ref)

  con
}

#' DuckDB relational backend
#'
#' TBD.
#'
#' @param df A data frame.
#' @return A relational object.
#'
#' @export
duckdb_rel_from_df <- function(df) {
  # FIXME: make generic
  stopifnot(is.data.frame(df))

  tryCatch(
    {
      rel <- duckdb:::rel_from_altrep_df(df)
      # Once we're here, we know it's an ALTREP data frame
      # We don't do anything if it's already materialized

      if (!duckdb:::df_is_materialized(df)) {
        rel_names <- duckdb:::rapi_rel_names(rel)
        if (!identical(rel_names, names(df))) {
          # This can happen when column names change for an existing relational data frame
          exprs <- nexprs_from_loc(rel_names, set_names(seq_along(df), names(df)))
          rel <- rel_project.duckdb_relation(rel, exprs)
        }
        return(rel)
      }
    },
    error = function(e) {}
  )

  # FIXME: Move to duckdb:::rel_from_df()

  if (!is_duckplyr_df(df)) {
    df <- as_duckplyr_df(df)
  }

  if (is.character(.row_names_info(df, 0L))) {
    stop("Need data frame without row names to convert to relational.")
  }

  for (i in seq_along(df)) {
    col <- .subset2(df, i)
    if (!is.null(names(col))) {
      stop("Can't convert named vectors to relational. Affected column: `", names(df)[[i]], "`.")
    }
    if (!is.null(dim(col))) {
      stop("Can't convert arrays or matrices to relational. Affected column: `", names(df)[[i]], "`.")
    }
    if (isS4(col)) {
      stop("Can't convert S4 columns to relational. Affected column: `", names(df)[[i]], "`.")
    }
    # https://github.com/duckdb/duckdb/issues/8561
    if (is.factor(col)) {
      stop("Can't convert factor columns to relational. Affected column: `", names(df)[[i]], "`.")
    }
  }

  # FIXME: For some reason, it's important to create an alias here
  con <- get_default_duckdb_connection()

  # FIXME: For some other reason, it seems crucial to assign the result to a
  # variable before returning it
  experimental <- (Sys.getenv("DUCKPLYR_EXPERIMENTAL") == "TRUE")
  out <- duckdb:::rel_from_df(con, df, experimental = experimental)

  roundtrip <- duckdb:::rapi_rel_to_altrep(out)
  if (Sys.getenv("DUCKPLYR_CHECK_ROUNDTRIP") == "TRUE") {
    rlang::with_options(duckdb.materialize_message = FALSE, {
      for (i in seq_along(df)) {
        if (!identical(df[[i]], roundtrip[[i]])) {
          stop("Imperfect roundtrip. Affected column: `", names(df)[[i]], "`.")
        }
      }
    })
  } else {
    for (i in seq_along(df)) {
      df_attrib <- attributes(df[[i]])
      roundtrip_attrib <- attributes(roundtrip[[i]])
      if (!identical(df_attrib, roundtrip_attrib)) {
        stop("Attributes are lost during conversion. Affected column: `", names(df)[[i]], "`.")
      }
    }
  }

  meta_rel_register_df(out, df)

  out

  # Causes protection errors
  # duckdb:::rel_from_df(get_default_duckdb_connection(), df)
}

#' @export
rel_to_df.duckdb_relation <- function(rel, ...) {
  duckdb:::rel_to_altrep(rel)
}

#' @export
rel_filter.duckdb_relation <- function(rel, exprs, ...) {
  duckdb_exprs <- to_duckdb_exprs(exprs)
  out <- duckdb:::rel_filter(rel, duckdb_exprs)

  meta_rel_register(out, expr(duckdb:::rel_filter(
    !!meta_rel_get(rel)$name,
    list(!!!to_duckdb_exprs_meta(exprs))
  )))

  out
}

#' @export
rel_project.duckdb_relation <- function(rel, exprs, ...) {
  duckdb_exprs <- to_duckdb_exprs(exprs)

  out <- duckdb:::rel_project(rel, duckdb_exprs)

  meta_rel_register(out, expr(duckdb:::rel_project(
    !!meta_rel_get(rel)$name,
    list(!!!to_duckdb_exprs_meta(exprs))
  )))

  out
}

#' @export
rel_aggregate.duckdb_relation <- function(rel, groups, aggregates, ...) {
  duckdb_groups <- to_duckdb_exprs(groups)
  duckdb_aggregates <- to_duckdb_exprs(aggregates)

  out <- duckdb:::rel_aggregate(
    rel,
    groups = duckdb_groups,
    aggregates = duckdb_aggregates
  )

  meta_rel_register(out, expr(duckdb:::rel_aggregate(
    !!meta_rel_get(rel)$name,
    groups = list(!!!to_duckdb_exprs_meta(groups)),
    aggregates = list(!!!to_duckdb_exprs_meta(aggregates))
  )))

  out
}

#' @export
rel_order.duckdb_relation <- function(rel, orders, ...) {
  duckdb_orders <- to_duckdb_exprs(orders)

  out <- duckdb:::rel_order(rel, duckdb_orders)

  meta_rel_register(out, expr(duckdb:::rel_order(
    !!meta_rel_get(rel)$name,
    list(!!!to_duckdb_exprs_meta(orders))
  )))

  out
}

#' @export
rel_join.duckdb_relation <- function(left, right, conds, join, join_ref_type, ...) {
  duckdb_conds <- to_duckdb_exprs(conds)
  if (join == "full") {
    join <- "outer"
  }

  if (join_ref_type == "regular") {
    # Compatibility with older duckdb versions
    out <- duckdb:::rel_join(left, right, duckdb_conds, join)

    meta_rel_register(out, expr(duckdb:::rel_join(
      !!meta_rel_get(left)$name,
      !!meta_rel_get(right)$name,
      list(!!!to_duckdb_exprs_meta(conds)),
      !!join
    )))
  } else {
    out <- duckdb:::rel_join(left, right, duckdb_conds, join, join_ref_type)

    meta_rel_register(out, expr(duckdb:::rel_join(
      !!meta_rel_get(left)$name,
      !!meta_rel_get(right)$name,
      list(!!!to_duckdb_exprs_meta(conds)),
      !!join,
      !!join_ref_type
    )))
  }

  out
}

#' @export
rel_limit.duckdb_relation <- function(rel, n, ...) {
  out <- duckdb:::rel_limit(rel, n)

  meta_rel_register(out, expr(duckdb:::rel_limit(
    !!meta_rel_get(rel)$name,
    !!n
  )))

  out
}

#' @export
rel_distinct.duckdb_relation <- function(rel, ...) {
  out <- duckdb:::rel_distinct(rel)

  meta_rel_register(out, expr(duckdb:::rel_distinct(
    !!meta_rel_get(rel)$name
  )))

  out
}

#' @export
rel_set_intersect.duckdb_relation <- function(rel_a, rel_b, ...) {
  out <- duckdb:::rel_set_intersect(rel_a, rel_b)

  meta_rel_register(out, expr(duckdb:::rel_set_intersect(
    !!meta_rel_get(rel_a)$name,
    !!meta_rel_get(rel_b)$name
  )))

  out
}

#' @export
rel_set_diff.duckdb_relation <- function(rel_a, rel_b, ...) {
  out <- duckdb:::rel_set_diff(rel_a, rel_b)

  meta_rel_register(out, expr(duckdb:::rel_set_diff(
    !!meta_rel_get(rel_a)$name,
    !!meta_rel_get(rel_b)$name
  )))

  out
}

#' @export
rel_set_symdiff.duckdb_relation <- function(rel_a, rel_b, ...) {
  out <- duckdb:::rel_set_symdiff(rel_a, rel_b)

  meta_rel_register(out, expr(duckdb:::rel_set_symdiff(
    !!meta_rel_get(rel_a)$name,
    !!meta_rel_get(rel_b)$name
  )))

  out
}

#' @export
rel_union_all.duckdb_relation <- function(rel_a, rel_b, ...) {
  out <- duckdb:::rel_union_all(rel_a, rel_b)

  meta_rel_register(out, expr(duckdb:::rel_union_all(
    !!meta_rel_get(rel_a)$name,
    !!meta_rel_get(rel_b)$name
  )))

  out
}

#' @export
rel_tostring.duckdb_relation <- function(rel, ...) {
}

#' @export
rel_explain.duckdb_relation <- function(rel, ...) {
  duckdb:::rel_explain(rel)
}

#' @export
rel_alias.duckdb_relation <- function(rel, ...) {
}

#' @export
rel_set_alias.duckdb_relation <- function(rel, alias, ...) {
  out <- duckdb:::rel_set_alias(rel, alias)

  meta_rel_register(out, expr(duckdb:::rel_set_alias(
    !!meta_rel_get(rel)$name,
    !!alias
  )))

  out
}

#' @export
rel_names.duckdb_relation <- function(rel, ...) {
  duckdb:::rapi_rel_names(rel)
}

to_duckdb_exprs <- function(exprs) {
  lapply(exprs, to_duckdb_expr)
}

to_duckdb_expr <- function(x) {
  switch(class(x)[[1]],
    relational_relexpr_reference = {
      out <- duckdb:::expr_reference(x$name, if (is.null(x$rel)) "" else x$rel)
      if (!is.null(x$alias)) {
        duckdb:::expr_set_alias(out, x$alias)
      }
      out
    },
    relational_relexpr_function = {
      out <- duckdb:::expr_function(x$name, to_duckdb_exprs(x$args))
      if (!is.null(x$alias)) {
        duckdb:::expr_set_alias(out, x$alias)
      }
      out
    },
    relational_relexpr_window = {
      out <- duckdb:::expr_window(
        to_duckdb_expr(x$expr),
        to_duckdb_exprs(x$partitions),
        to_duckdb_exprs(x$order_bys),
        offset_expr = to_duckdb_expr(x$offset_expr),
        default_expr = to_duckdb_expr(x$default_expr)
      )
      if (!is.null(x$alias)) {
        duckdb:::expr_set_alias(out, x$alias)
      }
      out
    },
    relational_relexpr_constant = {
      if ("experimental" %in% names(formals(duckdb:::expr_constant))) {
        experimental <- (Sys.getenv("DUCKPLYR_EXPERIMENTAL") == "TRUE")
        out <- duckdb:::expr_constant(x$val, experimental = experimental)
      } else {
        out <- duckdb:::expr_constant(x$val)
      }
      if (!is.null(x$alias)) {
        duckdb:::expr_set_alias(out, x$alias)
      }
      out
    },
    NULL = NULL,
    stop("Unknown expr class: ", class(x)[[1]])
  )
}

to_duckdb_exprs_meta <- function(exprs) {
  lapply(exprs, to_duckdb_expr_meta)
}

to_duckdb_expr_meta <- function(x) {
  switch(class(x)[[1]],
    relational_relexpr_reference = {
      args <- list(x$name)
      if (!is.null(x$rel)) {
        args <- c(args, meta_rel_get(x$rel)$name)
      }
      out <- expr(duckdb:::expr_reference(!!!args))
      if (!is.null(x$alias)) {
        out <- expr({
          tmp_expr <- !!out
          duckdb:::expr_set_alias(tmp_expr, !!x$alias)
          tmp_expr
        })
      }
      out
    },
    relational_relexpr_function = {
      meta_macro_register(x$name)
      out <- expr(duckdb:::expr_function(!!x$name, list(!!!to_duckdb_exprs_meta(x$args))))
      if (!is.null(x$alias)) {
        out <- expr({
          tmp_expr <- !!out
          duckdb:::expr_set_alias(tmp_expr, !!x$alias)
          tmp_expr
        })
      }
      out
    },
    relational_relexpr_window = {
      out <- expr(duckdb:::expr_window(
        !!to_duckdb_expr_meta(x$expr),
        list(!!!to_duckdb_exprs_meta(x$partitions)),
        list(!!!to_duckdb_exprs_meta(x$order_bys)),
        offset_expr = !!to_duckdb_expr_meta(x$offset_expr),
        default_expr = !!to_duckdb_expr_meta(x$default_expr)
      ))
      if (!is.null(x$alias)) {
        out <- expr({
          tmp_expr <- !!out
          duckdb:::expr_set_alias(tmp_expr, !!x$alias)
          tmp_expr
        })
      }
      out
    },
    relational_relexpr_constant = {
      out <- expr(
        # FIXME: always pass experimental flag once it's merged
        if ("experimental" %in% names(formals(duckdb:::expr_constant))) {
          # experimental is set at the top
          duckdb:::expr_constant(!!x$val, experimental = experimental)
        } else {
          duckdb:::expr_constant(!!x$val)
        }
      )

      if (!is.null(x$alias)) {
        out <- expr({
          tmp_expr <- !!out
          duckdb:::expr_set_alias(tmp_expr, !!x$alias)
          tmp_expr
        })
      }
      out
    },
    NULL = expr(NULL),
    stop("Unknown expr class: ", class(x)[[1]])
  )
}

#' Relational expressions
#'
#' TBD.
#'
#' @param x An object.
#' @param class Classes added in front of the `"relational_relexpr"` base class.
#'
#' @name expr
#' @export
new_relexpr <- function(x, class = NULL) {
  structure(x, class = unique(c(class, "relational_relexpr")))
}

#' @param name The name of the column or function to reference.
#' @param rel The name of the relation to reference.
#' @param alias An alias for the new expression.
#' @rdname expr
#' @export
relexpr_reference <- function(name, rel = NULL, alias = NULL) {
  stopifnot(is_string(name))
  stopifnot(is.null(rel) || inherits(rel, "duckdb_relation"))
  stopifnot(is.null(alias) || is_string(alias))
  new_relexpr(list(name = name, rel = rel, alias = alias), class = "relational_relexpr_reference")
}

#' @param val The value to use in the constant expression.
#' @rdname expr
#' @export
relexpr_constant <- function(val, alias = NULL) {
  stopifnot(length(val) == 1)
  stopifnot(is.null(alias) || is_string(alias))
  new_relexpr(list(val = val, alias = alias), class = "relational_relexpr_constant")
}

#' @param args Function arguments, a list of `expr` objects.
#' @rdname expr
#' @export
relexpr_function <- function(name, args, alias = NULL) {
  stopifnot(is_string(name))
  stopifnot(is.list(args))
  stopifnot(is.null(alias) || is_string(alias))
  new_relexpr(list(name = name, args = args, alias = alias), class = "relational_relexpr_function")
}

#' @param partitions Partitions, a list of `expr` objects.
#' @param order_bys which variables to order results by (list).
#' @param offset_expr offset relational expression.
#' @param default_expr default relational expression.
#' @rdname expr
#' @export
relexpr_window <- function(
    expr,
    partitions,
    order_bys = list(),
    offset_expr = NULL,
    default_expr = NULL,
    alias = NULL
) {
  stopifnot(inherits(expr, "relational_relexpr"))
  stopifnot(is.list(partitions))
  stopifnot(is.list(order_bys))
  stopifnot(is.null(offset_expr) || inherits(offset_expr, "relational_relexpr"))
  stopifnot(is.null(default_expr) || inherits(default_expr, "relational_relexpr"))
  stopifnot(is.null(alias) || is_string(alias))
  new_relexpr(
    list(
      expr = expr,
      partitions = partitions,
      order_bys = order_bys,
      offset_expr = offset_expr,
      default_expr = default_expr,
      alias = alias
    ),
    class = "relational_relexpr_window"
  )
}

#' @param expr An `expr` object.
#' @rdname expr
#' @export
relexpr_set_alias <- function(expr, alias = NULL) {
  stopifnot(inherits(expr, "relational_relexpr"))
  stopifnot(is.null(alias) || is_string(alias))
  expr$alias <- alias
  expr
}

#' @export
print.relational_relexpr <- function(x, ...) {
  writeLines(format(x, ...))
}

#' @export
format.relational_relexpr <- function(x, ...) {
  # FIXME: Use home-grown code
  utils::capture.output(print(constructive::construct(x)))
}

rel_stats_env <- new.env(parent = emptyenv(), size = 937L)

rel_stats_clean <- function() {
  rm(list = ls(rel_stats_env, all.names = TRUE), pos = rel_stats_env)
}

rel_stats_get <- function() {
  arrange(tibble::enframe(unlist(as.list(rel_stats_env)), "fun", "count"), desc(count))
}

#' Relational API
#'
#' TBD.
#'
#' @param ... Passed on to [structure()]
#' @param class Classes added in front of the `"relational"` base class
#'
#' @export
new_relational <- function(..., class = NULL) {
  structure(..., class = unique(c(class, "relational")))
}

#' Convert a relation object to a data frame
#'
#' TBD.
#'
#' @param rel The relation object.
#' @param ... Reserved for future extensions, must be empty.
#' @return A data frame.
#' @export
#' @examples
#' rel <- rel_from_df(mtcars)
#' rel2 <- rel_filter(
#'   rel,
#'   list(
#'     relexpr_function(
#'       "gt",
#'       list(relexpr_reference("cyl"), relexpr_constant("6"))
#'    )
#'   )
#'  )
rel_to_df <- function(rel, ...) {
  rel_stats_env$rel_to_df <- (rel_stats_env$rel_to_df %||% 0L) + 1L
  UseMethod("rel_to_df")
}

#' Lazily filter a relation object
#'
#' TBD.
#'
#' @inheritParams rel_to_df
#' @param exprs a list of DuckDB expressions to filter by
#' @return the now filtered relation object
#' @export
#' @examples
#' rel <- rel_from_df(mtcars)
#' rel2 <- rel_filter(
#'   rel,
#'   list(
#'     relexpr_function(
#'       "gt",
#'       list(relexpr_reference("cyl"), relexpr_constant("6")))
#'   )
#' )
rel_filter <- function(rel, exprs, ...) {
  rel_stats_env$rel_filter <- (rel_stats_env$rel_filter %||% 0L) + 1L
  UseMethod("rel_filter")
}

#' Lazily project a relation object
#'
#' TBD.
#'
#' @inheritParams rel_to_df
#' @param exprs a list of DuckDB expressions to project
#' @return the now projected relation object
#' @export
#' @examples
#' rel <- rel_from_df(mtcars)
#' rel2 <- rel_project(rel, list(relexpr_reference("cyl"), relexpr_reference("disp")))
rel_project <- function(rel, exprs, ...) {
  rel_stats_env$rel_project <- (rel_stats_env$rel_project %||% 0L) + 1L
  UseMethod("rel_project")
}

#' Lazily aggregate a relation object
#'
#' TBD.
#'
#' @inheritParams rel_to_df
#' @param groups a list of DuckDB expressions to group by
#' @param aggregates a (optionally named) list of DuckDB expressions with aggregates to compute
#' @return the now aggregated relation object
#' @export
#' @examples
#' rel <- rel_from_df(mtcars)
#' aggrs <- list(avg_hp = relexpr_function("avg", list(relexpr_reference("hp"))))
#' rel2 <- rel_aggregate(rel, list(relexpr_reference("cyl")), aggrs)
rel_aggregate <- function(rel, groups, aggregates, ...) {
  rel_stats_env$rel_aggregate <- (rel_stats_env$rel_aggregate %||% 0L) + 1L
  UseMethod("rel_aggregate")
}

#' Lazily reorder a relation object
#'
#' TBD.
#'
#' @inheritParams rel_to_df
#' @param orders a list of DuckDB expressions to order by
#' @return the now aggregated relation object
#' @export
#' @examples
#' rel <- rel_from_df(mtcars)
#' rel2 <- rel_order(rel, list(relexpr_reference("hp")))
rel_order <- function(rel, orders, ...) {
  rel_stats_env$rel_order <- (rel_stats_env$rel_order %||% 0L) + 1L
  UseMethod("rel_order")
}

#' Lazily INNER join two relation objects
#'
#' TBD.
#'
#' @inheritParams rel_to_df
#' @param left the left-hand-side relation object
#' @param right the right-hand-side relation object
#' @param conds a list of DuckDB expressions to use for the join
#' @param join type of join
#' @return a new relation object resulting from the join
#' @export
#' @examples
#' \dontrun{
#' left <- rel_from_df(mtcars)
#' right <- rel_from_df(mtcars)
#' cond <- list(
#'   relexpr_function(
#'     "eq",
#'     list(relexpr_reference("cyl", left), relexpr_reference("cyl", right))
#'   )
#' )
#' rel2 <- rel_join(left, right, cond)
#' }
rel_join <- function(left,
                     right,
                     conds,
                     join = c("inner", "left", "right", "outer", "cross", "semi", "anti"),
                     join_ref_type = c("regular", "natural", "cross", "positional", "asof"),
                     ...) {
  rel_stats_env$rel_join <- (rel_stats_env$rel_join %||% 0L) + 1L
  UseMethod("rel_join")
}

#' Lazily limit the rows in a relation object
#'
#' TBD.
#'
#' @inheritParams rel_to_df
#' @param n The number of rows.
#' @export
rel_limit <- function(rel, n, ...) {
  rel_stats_env$rel_limit <- (rel_stats_env$rel_limit %||% 0L) + 1L
  UseMethod("rel_limit")
}

#' Lazily compute a distinct result on a relation object
#'
#' TBD.
#'
#' @inheritParams rel_to_df
#' @return a new relation object with distinct rows
#' @export
#' @examples
#' rel <- rel_from_df(mtcars)
#' rel2 <- rel_distinct(rel)
rel_distinct <- function(rel, ...) {
  rel_stats_env$rel_distinct <- (rel_stats_env$rel_distinct %||% 0L) + 1L
  UseMethod("rel_distinct")
}

#' Lazily compute a set_intersect result on a relation object
#'
#' TBD.
#'
#' @inheritParams rel_to_df
#' @inheritParams rel_set_diff
#' @return a new relation object with the result
#' @export
#' @examples
#' rel <- rel_from_df(mtcars)
#' rel2 <- rel_set_intersect(rel)
rel_set_intersect <- function(rel_a, rel_b, ...) {
  rel_stats_env$rel_set_intersect <- (rel_stats_env$rel_set_intersect %||% 0L) + 1L
  UseMethod("rel_set_intersect")
}

#' Lazily compute a set_diff result on a relation object
#'
#' TBD.
#'
#' @inheritParams rel_to_df
#' @param rel_a a DuckDB relation object
#' @param rel_b a DuckDB relation object
#' @return a new relation object with the result
#' @export
#' @examples
#' rel <- rel_from_df(mtcars)
#' rel2 <- rel_set_diff(rel)
rel_set_diff <- function(rel_a, rel_b, ...) {
  rel_stats_env$rel_set_diff <- (rel_stats_env$rel_set_diff %||% 0L) + 1L
  UseMethod("rel_set_diff")
}

#' Lazily compute a set_symdiff result on a relation object
#'
#' TBD.
#'
#' @inheritParams rel_to_df
#' @inheritParams rel_set_diff
#' @return a new relation object with the result
#' @export
#' @examples
#' rel <- rel_from_df(mtcars)
#' rel2 <- rel_set_symdiff(rel)
rel_set_symdiff <- function(rel_a, rel_b, ...) {
  rel_stats_env$rel_set_symdiff <- (rel_stats_env$rel_set_symdiff %||% 0L) + 1L
  UseMethod("rel_set_symdiff")
}

#' Lazily compute a set_union_all result on a relation object
#'
#' TBD.
#'
#' @inheritParams rel_to_df
#' @inheritParams rel_set_diff
#' @return a new relation object with the result
#' @export
#' @examples
#' rel <- rel_from_df(mtcars)
#' rel2 <- rel_union_all(rel)
rel_union_all <- function(rel_a, rel_b, ...) {
  rel_stats_env$rel_union_all <- (rel_stats_env$rel_union_all %||% 0L) + 1L
  UseMethod("rel_union_all")
}

#' TBD
#'
#' TBD.
#'
#' @inheritParams rel_to_df
#' @rdname rel
#' @export
rel_tostring <- function(rel, ...) {
  rel_stats_env$rel_tostring <- (rel_stats_env$rel_tostring %||% 0L) + 1L
  UseMethod("rel_tostring")
}

#' Print the EXPLAIN output for a relation object
#'
#' TBD.
#'
#' @inheritParams rel_to_df
#' @export
#' @examples
#' rel <- rel_from_df(mtcars)
#' rel_explain(rel)
rel_explain <- function(rel, ...) {
  rel_stats_env$rel_explain <- (rel_stats_env$rel_explain %||% 0L) + 1L
  UseMethod("rel_explain")
}

#' Get the internal alias for a relation object
#'
#' TBD.
#'
#' @inheritParams rel_to_df
#' @export
#' @examples
#' rel <- rel_from_df(mtcars)
#' rel_alias(rel)
rel_alias <- function(rel, ...) {
  rel_stats_env$rel_alias <- (rel_stats_env$rel_alias %||% 0L) + 1L
  UseMethod("rel_alias")
}

#' Set the internal alias for a relation object
#'
#' TBD.
#'
#' @inheritParams rel_to_df
#' @param alias the new alias
#' @export
#' @examples
#' rel <- rel_from_df(mtcars)
#' rel_set_alias(rel, "my_new_alias")
rel_set_alias <- function(rel, alias, ...) {
  rel_stats_env$rel_set_alias <- (rel_stats_env$rel_set_alias %||% 0L) + 1L
  UseMethod("rel_set_alias")
}

#' @rdname rel
#' @export
rel_names <- function(rel, ...) {
  rel_stats_env$rel_names <- (rel_stats_env$rel_names %||% 0L) + 1L
  UseMethod("rel_names")
}

rel_try <- function(rel, ...) {
  call <- as.character(sys.call(-1)[[1]])

  if (!(list(call) %in% stats$calls)) {
    stats$calls <- c(stats$calls, call)
  }

  stats$attempts <- stats$attempts + 1L

  dots <- list(...)
  for (i in seq_along(dots)) {
    if (isTRUE(dots[[i]])) {
      stats$fallback <- stats$fallback + 1L
      if (!dplyr_mode) {
        if (Sys.getenv("DUCKPLYR_FALLBACK_INFO") == "TRUE") {
          inform(message = c("Requested fallback for relational:", i = names(dots)[[i]]))
        }
        if (Sys.getenv("DUCKPLYR_FORCE") == "TRUE") {
          abort("Fallback not available with DUCKPLYR_FORCE")
        }
      }

      return()
    }
  }

  if (Sys.getenv("DUCKPLYR_FORCE") == "TRUE") {
    return(rel)
  }

  out <- rlang::try_fetch(rel, error = identity)
  if (inherits(out, "error")) {
    # FIXME: enable always
    if (Sys.getenv("DUCKPLYR_FALLBACK_INFO") == "TRUE") {
      rlang::cnd_signal(rlang::message_cnd(message = "Error processing with relational.", parent = out))
    }
    stats$fallback <- stats$fallback + 1L
    return()
  }

  # Never reached due to return() in code
  stop("Must use a return() in rel_try().")
}

rel_translate_dots <- function(dots, data) {
  if (is.null(names(dots))) {
    map(dots, rel_translate, data)
  } else {
    imap(dots, rel_translate, data = data)
  }
}

rel_translate <- function(
    quo, data,
    alias = NULL,
    partition = NULL,
    need_window = FALSE,
    names_data = names(data)
) {
  if (is_expression(quo)) {
    expr <- quo
    env <- baseenv()
  } else {
    expr <- quo_get_expr(quo)
    env <- quo_get_env(quo)
  }

  used <- character()

  do_translate <- function(expr, in_window = FALSE) {
    if (is_quosure(expr)) {
      # FIXME: What to do with the environment here?
      expr <- quo_get_expr(expr)
    }

    switch(typeof(expr),
      character = ,
      logical = ,
      integer = ,
      double = relexpr_constant(expr),
      #
      symbol = {
        if (as.character(expr) %in% names_data) {
          ref <- as.character(expr)
          if (!(ref %in% used)) {
            used <<- c(used, ref)
          }
          relexpr_reference(ref)
        } else {
          val <- eval_tidy(expr, env = env)
          relexpr_constant(val)
        }
      },
      #
      language = {
        name <- as.character(expr[[1]])

        switch(name,
          "(" = {
            return(do_translate(expr[[2]], in_window = in_window))
          },
          # Hack
          "wday" = {
            def <- lubridate::wday
            call <- match.call(def, expr, envir = env)
            args <- as.list(call[-1])
            bad <- !(names(args) %in% c("x"))
            if (any(bad)) {
              abort(paste0(name, "(", names(args)[which(bad)[[1]]], " = ) not supported"))
            }
            if (!is.null(getOption("lubridate.week.start"))) {
              abort('wday() with option("lubridate.week.start") not supported')
            }
          },
          "strftime" = {
            def <- strftime
            call <- match.call(def, expr, envir = env)
            args <- as.list(call[-1])
            bad <- !(names(args) %in% c("x", "format"))
            if (any(bad)) {
              abort(paste0(name, "(", names(args)[which(bad)[[1]]], " = ) not supported"))
            }
          },
          "%in%" = {
            tryCatch(
              {
                values <- eval(expr[[3]], envir = baseenv())
                consts <- map(values, do_translate, in_window = in_window)
                ops <- map(consts, list, do_translate(expr[[2]]))
                cmp <- map(ops, relexpr_function, name = "___base_r_eq")
                alt <- reduce(cmp, ~ relexpr_function("|", list(.x, .y)))
                return(alt)
              },
              error = identity
            )
          }
        )

        aliases <- c(
          sd = "stddev",
          first = "first_value",
          last = "last_value",
          nth = "nth_value",
          "/" = "___divide",
          "==" = "___base_r_eq",
          NULL
        )

        known_window <- c(
          # Window functions
          "rank", "rank_dense", "dense_rank", "percent_rank",
          "row_number", "first_value", "last_value", "nth_value",
          "cume_dist", "lead", "lag", "ntile",

          # Aggregates
          "sum", "mean", "stddev", "min", "max", "median",

          NULL
        )

        known_ops <- c("+", "-", "*", "/")

        known_funs <- c(
          # FIXME: How to indicate these are from lubridate?
          "hour",
          "minute",
          "second",
          "strftime",
          "abs",
          "%in%",
          "substr",

          NULL
        )

        known <- c(names(duckplyr_macros), names(aliases), known_window, known_ops, known_funs)

        if (!(name %in% known)) {
          abort(paste0("Unknown function: ", name))
        }

        if (name %in% names(aliases)) {
          name <- aliases[[name]]
        }
        # name <- aliases[name] %|% name

        window <- need_window && (name %in% known_window)

        order_bys <- list()
        offset_expr <- NULL
        default_expr <- NULL
        if (name %in% c("lag", "lead")) {
          # x, n = 1L, default = NULL, order_by = NULL
          expr <- match.call(lag, expr)

          offset_expr <- relexpr_constant(expr$n %||% 1L)
          expr$n <- NULL

          if (!is.null(expr$default)) {
            default_expr <- do_translate(expr$default, in_window = TRUE)
            expr$default <- NULL
          }

          if (!is.null(expr$order_by)) {
            order_bys <- list(do_translate(expr$order_by, in_window = TRUE))
            expr$order_by <- NULL
          }
        }

        args <- map(as.list(expr[-1]), do_translate, in_window = in_window || window)
        fun <- relexpr_function(name, args)
        if (window) {
          partitions <- map(partition, relexpr_reference)
          fun <- relexpr_window(
            fun,
            partitions,
            order_bys,
            offset_expr = offset_expr,
            default_expr = default_expr
          )
        }
        fun
      },
      #
      abort(paste0("Internal: Unknown type ", typeof(expr)))
    )
  }

  out <- do_translate(expr)

  if (!is.null(alias) && !identical(alias, "")) {
    out <- relexpr_set_alias(out, alias)
  }

  structure(out, used = used)
}

# Generated by 02-duckplyr_df-methods.R
#' @export
relocate.data.frame <- function(.data, ..., .before = NULL, .after = NULL) {
  loc <- eval_relocate(
    expr = expr(c(...)),
    data = .data,
    before = enquo(.before),
    after = enquo(.after),
    before_arg = ".before",
    after_arg = ".after"
  )

  exprs <- exprs_from_loc(.data, loc)

  # Ensure `relocate()` appears in call stack
  rel_try(
    "Can't use relational with zero-column result set." = (length(exprs) == 0),
    {
      rel <- duckdb_rel_from_df(.data)
      out <- exprs_project(rel, exprs, .data)
      return(out)
    }
  )

  # dplyr forward
  relocate <- relocate_data_frame
  out <- relocate(.data, ..., .before = {{ .before }}, .after = {{ .after }})
  return(out)

  # dplyr implementation
  loc <- eval_relocate(
    expr = expr(c(...)),
    data = .data,
    before = enquo(.before),
    after = enquo(.after),
    before_arg = ".before",
    after_arg = ".after"
  )

  out <- dplyr_col_select(.data, loc)
  out <- set_names(out, names(loc))

  out
}

duckplyr_relocate <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- relocate(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
rename.data.frame <- function(.data, ...) {
  loc <- tidyselect::eval_rename(expr(c(...)), .data)
  dupes <- duplicated(loc, fromLast = TRUE)
  loc <- loc[!dupes]

  # eval_rename() only returns changes
  proj <- rlang::set_names(seq_along(.data), names(.data))
  names(proj)[loc] <- names(loc)

  exprs <- exprs_from_loc(.data, proj)

  rel_try(
    "Can't use relational with zero-column result set." = (length(exprs) == 0),
    {
      rel <- duckdb_rel_from_df(.data)
      out <- exprs_project(rel, exprs, .data)
      return(out)
    }
  )

  # dplyr forward
  rename <- rename_data_frame
  out <- rename(.data, ...)
  return(out)

  # dplyr implementation
  loc <- tidyselect::eval_rename(expr(c(...)), .data)
  # eval_rename() only returns changes
  names <- names(.data)
  names[loc] <- names(loc)

  set_names(.data, names)
}

duckplyr_rename <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- rename(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
rename_with.data.frame <- function(.data, .fn, .cols = everything(), ...) {
  # Our implementation
  rel_try(
    "No relational implementation for rename_with()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  rename_with <- rename_with_data_frame
  out <- rename_with(.data, .fn, {{ .cols }}, ...)
  return(out)

  # dplyr implementation
  .fn <- as_function(.fn)
  cols <- tidyselect::eval_select(enquo(.cols), .data, allow_rename = FALSE)

  names <- names(.data)

  sel <- vec_slice(names, cols)
  new <- .fn(sel, ...)

  if (!is_character(new)) {
    cli::cli_abort(
      "{.arg .fn} must return a character vector, not {.obj_type_friendly {new}}."
    )
  }
  if (length(new) != length(sel)) {
    cli::cli_abort(
      "{.arg .fn} must return a vector of length {length(sel)}, not {length(new)}."
    )
  }

  names <- vec_assign(names, cols, new)
  names <- vec_as_names(names, repair = "check_unique")

  set_names(.data, names)
}

duckplyr_rename_with <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- rename_with(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
right_join.data.frame <- function(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ..., keep = NULL, na_matches = c("na", "never"), multiple = "all", unmatched = "drop", relationship = NULL) {
  check_dots_empty0(...)
  error_call <- caller_env()

  # Our implementation
  rel_try(
    "No implicit cross joins for right_join()" = is_cross_by(by),
    "No relational implementation for right_join(copy = TRUE)" = copy,
    {
      out <- rel_join_impl(x, y, by, "right", na_matches, suffix, keep, error_call)
      return(out)
    }
  )

  # dplyr forward
  right_join <- right_join_data_frame
  out <- right_join(x, y, by, copy, suffix, ..., keep = keep, na_matches = na_matches, multiple = multiple, unmatched = unmatched, relationship = relationship)
  return(out)

  # dplyr implementation
  check_dots_empty0(...)
  y <- auto_copy(x, y, copy = copy)
  join_mutate(
    x = x,
    y = y,
    by = by,
    type = "right",
    suffix = suffix,
    na_matches = na_matches,
    keep = keep,
    multiple = multiple,
    unmatched = unmatched,
    relationship = relationship,
    user_env = caller_env()
  )
}

duckplyr_right_join <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- right_join(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
rows_append.data.frame <- function(x, y, ..., copy = FALSE, in_place = FALSE) {
  # Our implementation
  rel_try(
    "No relational implementation for rows_append()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  rows_append <- rows_append_data_frame
  out <- rows_append(x, y, ..., copy = copy, in_place = in_place)
  return(out)

  # dplyr implementation
  check_dots_empty()
  rows_df_in_place(in_place)

  y <- auto_copy(x, y, copy = copy)

  rows_check_x_contains_y(x, y)
  y <- rows_cast_y(y, x)

  rows_bind(x, y)
}

duckplyr_rows_append <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- rows_append(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
rows_delete.data.frame <- function(x, y, by = NULL, ..., unmatched = c("error", "ignore"), copy = FALSE, in_place = FALSE) {
  # Our implementation
  rel_try(
    "No relational implementation for rows_delete()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  rows_delete <- rows_delete_data_frame
  out <- rows_delete(x, y, by, ..., unmatched = unmatched, copy = copy, in_place = in_place)
  return(out)

  # dplyr implementation
  check_dots_empty()
  rows_df_in_place(in_place)

  y <- auto_copy(x, y, copy = copy)

  by <- rows_check_by(by, y)

  rows_check_contains_by(x, by, "x")
  rows_check_contains_by(y, by, "y")

  x_key <- dplyr_col_select(x, by)
  y_key <- dplyr_col_select(y, by)

  args <- vec_cast_common(x = x_key, y = y_key)
  x_key <- args$x
  y_key <- args$y

  keep <- rows_check_y_unmatched(x_key, y_key, unmatched)

  if (!is.null(keep)) {
    y_key <- dplyr_row_slice(y_key, keep)
  }

  extra <- setdiff(names(y), names(y_key))
  if (!is_empty(extra)) {
    message <- glue("Ignoring extra `y` columns: ", commas(tick_if_needed(extra)))
    inform(message, class = c("dplyr_message_delete_extra_cols", "dplyr_message"))
  }

  loc <- vec_match(x_key, y_key)
  unmatched <- is.na(loc)

  x_loc <- which(unmatched)

  dplyr_row_slice(x, x_loc)
}

duckplyr_rows_delete <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- rows_delete(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
rows_insert.data.frame <- function(x, y, by = NULL, ..., conflict = c("error", "ignore"), copy = FALSE, in_place = FALSE) {
  # Our implementation
  rel_try(
    "No relational implementation for rows_insert()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  rows_insert <- rows_insert_data_frame
  out <- rows_insert(x, y, by, ..., conflict = conflict, copy = copy, in_place = in_place)
  return(out)

  # dplyr implementation
  check_dots_empty()
  rows_df_in_place(in_place)

  y <- auto_copy(x, y, copy = copy)

  by <- rows_check_by(by, y)

  rows_check_x_contains_y(x, y)
  rows_check_contains_by(x, by, "x")
  rows_check_contains_by(y, by, "y")

  y <- rows_cast_y(y, x)

  x_key <- dplyr_col_select(x, by)
  y_key <- dplyr_col_select(y, by)

  keep <- rows_check_y_conflict(x_key, y_key, conflict)

  if (!is.null(keep)) {
    y <- dplyr_row_slice(y, keep)
  }

  rows_bind(x, y)
}

duckplyr_rows_insert <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- rows_insert(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
rows_patch.data.frame <- function(x, y, by = NULL, ..., unmatched = c("error", "ignore"), copy = FALSE, in_place = FALSE) {
  # Our implementation
  rel_try(
    "No relational implementation for rows_patch()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  rows_patch <- rows_patch_data_frame
  out <- rows_patch(x, y, by, ..., unmatched = unmatched, copy = copy, in_place = in_place)
  return(out)

  # dplyr implementation
  check_dots_empty()
  rows_df_in_place(in_place)

  y <- auto_copy(x, y, copy = copy)

  by <- rows_check_by(by, y)

  rows_check_x_contains_y(x, y)
  rows_check_contains_by(x, by, "x")
  rows_check_contains_by(y, by, "y")

  x_key <- dplyr_col_select(x, by)
  y_key <- dplyr_col_select(y, by)

  rows_check_unique(y_key, "y")

  args <- vec_cast_common(x = x_key, y = y_key)
  x_key <- args$x
  y_key <- args$y

  values_names <- setdiff(names(y), names(y_key))

  x_values <- dplyr_col_select(x, values_names)
  y_values <- dplyr_col_select(y, values_names)
  y_values <- rows_cast_y(y_values, x_values)

  keep <- rows_check_y_unmatched(x_key, y_key, unmatched)

  if (!is.null(keep)) {
    y_key <- dplyr_row_slice(y_key, keep)
    y_values <- dplyr_row_slice(y_values, keep)
  }

  loc <- vec_match(x_key, y_key)
  match <- !is.na(loc)

  y_loc <- loc[match]
  x_loc <- which(match)

  x_slice <- dplyr_row_slice(x_values, x_loc)
  x_slice <- dplyr_new_list(x_slice)

  y_slice <- dplyr_row_slice(y_values, y_loc)
  y_slice <- dplyr_new_list(y_slice)

  x_patched <- map2(x_slice, y_slice, coalesce)
  x_patched <- new_data_frame(x_patched, n = length(x_loc))

  x_values <- vec_assign(x_values, x_loc, x_patched)
  x_values <- dplyr_new_list(x_values)

  x <- dplyr_col_modify(x, x_values)

  x
}

duckplyr_rows_patch <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- rows_patch(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
rows_update.data.frame <- function(x, y, by = NULL, ..., unmatched = c("error", "ignore"), copy = FALSE, in_place = FALSE) {
  # Our implementation
  rel_try(
    "No relational implementation for rows_update()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  rows_update <- rows_update_data_frame
  out <- rows_update(x, y, by, ..., unmatched = unmatched, copy = copy, in_place = in_place)
  return(out)

  # dplyr implementation
  check_dots_empty()
  rows_df_in_place(in_place)

  y <- auto_copy(x, y, copy = copy)

  by <- rows_check_by(by, y)

  rows_check_x_contains_y(x, y)
  rows_check_contains_by(x, by, "x")
  rows_check_contains_by(y, by, "y")

  x_key <- dplyr_col_select(x, by)
  y_key <- dplyr_col_select(y, by)

  rows_check_unique(y_key, "y")

  args <- vec_cast_common(x = x_key, y = y_key)
  x_key <- args$x
  y_key <- args$y

  values_names <- setdiff(names(y), names(y_key))

  x_values <- dplyr_col_select(x, values_names)
  y_values <- dplyr_col_select(y, values_names)
  y_values <- rows_cast_y(y_values, x_values)

  keep <- rows_check_y_unmatched(x_key, y_key, unmatched)

  if (!is.null(keep)) {
    y_key <- dplyr_row_slice(y_key, keep)
    y_values <- dplyr_row_slice(y_values, keep)
  }

  loc <- vec_match(x_key, y_key)
  match <- !is.na(loc)

  y_loc <- loc[match]
  x_loc <- which(match)

  y_values <- dplyr_row_slice(y_values, y_loc)

  x_values <- vec_assign(x_values, x_loc, y_values)
  x_values <- dplyr_new_list(x_values)

  x <- dplyr_col_modify(x, x_values)

  x
}

duckplyr_rows_update <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- rows_update(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
rows_upsert.data.frame <- function(x, y, by = NULL, ..., copy = FALSE, in_place = FALSE) {
  # Our implementation
  rel_try(
    "No relational implementation for rows_upsert()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  rows_upsert <- rows_upsert_data_frame
  out <- rows_upsert(x, y, by, ..., copy = copy, in_place = in_place)
  return(out)

  # dplyr implementation
  check_dots_empty()
  rows_df_in_place(in_place)

  y <- auto_copy(x, y, copy = copy)

  by <- rows_check_by(by, y)

  rows_check_x_contains_y(x, y)
  rows_check_contains_by(x, by, "x")
  rows_check_contains_by(y, by, "y")

  x_key <- dplyr_col_select(x, by)
  y_key <- dplyr_col_select(y, by)

  rows_check_unique(y_key, "y")

  args <- vec_cast_common(x = x_key, y = y_key)
  x_key <- args$x
  y_key <- args$y

  values_names <- setdiff(names(y), names(y_key))

  x_values <- dplyr_col_select(x, values_names)
  y_values <- dplyr_col_select(y, values_names)
  y_values <- rows_cast_y(y_values, x_values)

  loc <- vec_match(x_key, y_key)
  match <- !is.na(loc)

  y_loc <- loc[match]
  x_loc <- which(match)

  # Update
  y_values <- dplyr_row_slice(y_values, y_loc)
  x_values <- vec_assign(x_values, x_loc, y_values)
  x_values <- dplyr_new_list(x_values)

  x <- dplyr_col_modify(x, x_values)

  # Insert
  y_size <- vec_size(y_key)
  y_extra <- dplyr:::vec_as_location_invert(y_loc, y_size)

  y <- dplyr_row_slice(y, y_extra)
  y <- rows_cast_y(y, x)

  x <- rows_bind(x, y)

  x
}

duckplyr_rows_upsert <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- rows_upsert(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
sample_frac.data.frame <- function(tbl, size = 1, replace = FALSE, weight = NULL, .env = NULL, ...) {
  # Our implementation
  rel_try(
    "No relational implementation for sample_frac()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  sample_frac <- sample_frac_data_frame
  out <- sample_frac(tbl, {{ size }}, replace, {{ weight }}, .env, ...)
  return(out)

  # dplyr implementation
  if (!is_null(.env)) {
    inform("`.env` is deprecated and no longer has any effect")
  }

  size <- enquo(size)
  weight <- enquo(weight)

  dplyr_local_error_call()
  slice(tbl, local({
    size <- round(n() * check_frac(!!size, replace = replace))
    sample.int(n(), size, replace = replace, prob = !!weight)
  }))
}

duckplyr_sample_frac <- function(tbl, ...) {
  try_fetch(
    tbl <- as_duckplyr_df(tbl),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- sample_frac(tbl, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
sample_n.data.frame <- function(tbl, size, replace = FALSE, weight = NULL, .env = NULL, ...) {
  # Our implementation
  rel_try(
    "No relational implementation for sample_n()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  sample_n <- sample_n_data_frame
  out <- sample_n(tbl, {{ size }}, replace, {{ weight }}, .env, ...)
  return(out)

  # dplyr implementation
  if (!is_null(.env)) {
    inform("`sample_n() argument `.env` is deprecated and no longer has any effect.")
  }

  size <- enquo(size)
  weight <- enquo(weight)

  dplyr_local_error_call()
  slice(tbl, local({
    size <- check_size(!!size, n(), replace = replace)
    sample.int(n(), size, replace = replace, prob = !!weight)
  }))
}

duckplyr_sample_n <- function(tbl, ...) {
  try_fetch(
    tbl <- as_duckplyr_df(tbl),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- sample_n(tbl, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
select.data.frame <- function(.data, ...) {
  force(.data)

  error_call <- dplyr_error_call()

  loc <- tidyselect::eval_select(
    expr(c(...)),
    data = .data,
    error_call = error_call
  )

  exprs <- exprs_from_loc(.data, loc)

  rel_try(
    "Can't use relational with zero-column result set." = (length(exprs) == 0),
    {
      rel <- duckdb_rel_from_df(.data)
      out <- exprs_project(rel, exprs, .data)
      return(out)
    }
  )


  # dplyr forward
  select <- select_data_frame
  out <- select(.data, ...)
  return(out)

  # dplyr implementation
  error_call <- dplyr_error_call()

  loc <- tidyselect::eval_select(
    expr(c(...)),
    data = .data,
    error_call = error_call
  )
  loc <- ensure_group_vars(loc, .data, notify = TRUE)

  out <- dplyr_col_select(.data, loc)
  out <- set_names(out, names(loc))

  out
}

duckplyr_select <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- select(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
semi_join.data.frame <- function(x, y, by = NULL, copy = FALSE, ..., na_matches = c("na", "never")) {
  check_dots_empty0(...)
  error_call <- caller_env()

  # https://github.com/duckdb/duckdb/issues/6597
  na_matches <- check_na_matches(na_matches, error_call = error_call)

  # Our implementation
  rel_try(
    "No relational implementation for semi_join(copy = TRUE)" = copy,
    {
      out <- rel_join_impl(x, y, by, "semi", na_matches, error_call = error_call)
      return(out)
    }
  )

  # dplyr forward
  semi_join <- semi_join_data_frame
  out <- semi_join(x, y, by, copy, ..., na_matches = na_matches)
  return(out)

  # dplyr implementation
  check_dots_empty0(...)
  y <- auto_copy(x, y, copy = copy)
  join_filter(x, y, by = by, type = "semi", na_matches = na_matches, user_env = caller_env())
}

duckplyr_semi_join <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- semi_join(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
setdiff.data.frame <- function(x, y, ...) {
  # Our implementation
  check_dots_empty()

  x_names <- names(x)
  y_names <- names(y)
  if (identical(x_names, y_names)) {
    # Ensure identical() is very cheap
    y_names <- x_names
  }

  rel_try(
    "No duplicate names" = !identical(x_names, y_names) && anyDuplicated(x_names) && anyDuplicated(y_names),
    "Tables of different width" = length(x_names) != length(y_names),
    "Name mismatch" = !identical(x_names, y_names) && !all(y_names %in% x_names),
    {
      x_rel <- duckdb_rel_from_df(x)
      y_rel <- duckdb_rel_from_df(y)
      if (!identical(x_names, y_names)) {
        # FIXME: Select by position
        exprs <- nexprs_from_loc(x_names, set_names(seq_along(x_names), x_names))
        y_rel <- rel_project(y_rel, exprs)
      }

      rel <- rel_set_diff(x_rel, y_rel)
      out <- rel_to_df(rel)
      out <- dplyr_reconstruct(out, x)
      return(out)
    }
  )

  # dplyr forward
  setdiff <- setdiff_data_frame
  out <- setdiff(x, y, ...)
  return(out)

  # dplyr implementation
  check_dots_empty()
  check_compatible(x, y)

  out <- vec_set_difference(x, y, error_call = current_env())

  dplyr_reconstruct(out, x)
}

duckplyr_setdiff <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- setdiff(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
setequal.data.frame <- function(x, y, ...) {
  # Our implementation
  rel_try(
    "No relational implementation for setequal()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  setequal <- setequal_data_frame
  out <- setequal(x, y, ...)
  return(out)

  # dplyr implementation
  check_dots_empty()
  check_compatible(x, y)

  cast <- vec_cast_common(x = x, y = y)
  all(vec_in(cast$x, cast$y)) && all(vec_in(cast$y, cast$x))
}

duckplyr_setequal <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- setequal(x, y, ...)
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
slice.data.frame <- function(.data, ..., .by = NULL, .preserve = FALSE) {
  # Our implementation
  rel_try(
    "No relational implementation for slice()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  slice <- slice_data_frame
  out <- slice(.data, ..., .by = {{ .by }}, .preserve = .preserve)
  return(out)

  # dplyr implementation
  check_dots_unnamed()

  dots <- enquos(...)

  by <- compute_by(
    by = {{ .by }},
    data = .data,
    by_arg = the$slice_by_arg,
    data_arg = ".data"
  )

  loc <- slice_rows(.data, dots, by)
  dplyr_row_slice(.data, loc, preserve = .preserve)
}

duckplyr_slice <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- slice(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
slice_head.data.frame <- function(.data, ..., n, prop, by = NULL) {
  # Our implementation
  rel_try(
    "No relational implementation for slice_head()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  slice_head <- slice_head_data_frame
  out <- slice_head(.data, ..., n = n, prop = prop, by = {{ by }})
  return(out)

  # dplyr implementation
  check_dots_empty0(...)

  size <- get_slice_size(n = n, prop = prop)
  idx <- function(n) {
    seq2(1, size(n))
  }

  dplyr_local_error_call()
  dplyr_local_slice_by_arg("by")

  slice(.data, idx(dplyr::n()), .by = {{ by }})
}

duckplyr_slice_head <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- slice_head(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
duckplyr_slice_max <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- slice_max(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
duckplyr_slice_min <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- slice_min(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
duckplyr_slice_sample <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- slice_sample(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
slice_tail.data.frame <- function(.data, ..., n, prop, by = NULL) {
  # Our implementation
  rel_try(
    "No relational implementation for slice_tail()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  slice_tail <- slice_tail_data_frame
  out <- slice_tail(.data, ..., n = n, prop = prop, by = {{ by }})
  return(out)

  # dplyr implementation
  check_dots_empty0(...)

  size <- get_slice_size(n = n, prop = prop)
  idx <- function(n) {
    seq2(n - size(n) + 1, n)
  }

  dplyr_local_error_call()
  dplyr_local_slice_by_arg("by")

  slice(.data, idx(dplyr::n()), .by = {{ by }})
}

duckplyr_slice_tail <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- slice_tail(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

stats <- new_environment(list(attempts = 0L, fallback = 0L, calls = character()))

#' @export
stats_show <- function() {
  writeLines(paste0(
    c("\U0001f6e0", "\U0001f528", "\U0001f986"),
    "️: ",
    format(c(stats$attempts, stats$fallback, stats$attempts - stats$fallback))
  ))
  calls <- sort(gsub("[.]duckplyr_df", "", stats$calls))
  writeLines(paste(calls, collapse = ", "))
}

# Generated by 02-duckplyr_df-methods.R
#' @export
summarise.data.frame <- function(.data, ..., .by = NULL, .groups = NULL) {
  force(.data)

  rel_try(
    'summarize(.groups = "rowwise") not supported' = identical(.groups, "rowwise"),
    {
      rel <- duckdb_rel_from_df(.data)

      by <- eval_select_by(enquo(.by), .data)

      dots <- dplyr_quosures(...)
      dots <- fix_auto_name(dots)

      oo <- (length(by) > 0) && oo_force()
      if (oo) {
        rel <- oo_prep(rel, colname = "___row_number", force = TRUE)
      }

      groups <- lapply(by, relexpr_reference)
      aggregates <- rel_translate_dots(dots, .data)

      if (oo) {
        aggregates <- c(
          list(rel_translate(
            quo(min(`___row_number`)),
            new_data_frame(list(`___row_number` = integer())),
            alias = "___row_number"
          )),
          aggregates
        )
      }

      out_rel <- rel_aggregate(rel, groups, unname(aggregates))
      # https://github.com/duckdb/duckdb/issues/7095
      if (length(groups) == 0) {
        out_rel <- rel_distinct(out_rel)
      }

      if (oo) {
        out_rel <- oo_restore(out_rel, "___row_number")
      }

      out <- rel_to_df(out_rel)
      class(out) <- class(.data)

      return(out)
    }
  )

  # dplyr forward
  summarise <- summarise_data_frame
  out <- summarise(.data, ..., .by = {{ .by }}, .groups = .groups)
  return(out)

  # dplyr implementation
  by <- compute_by({{ .by }}, .data, by_arg = ".by", data_arg = ".data")

  cols <- summarise_cols(.data, dplyr_quosures(...), by, "summarise")
  out <- summarise_build(by, cols)

  if (!cols$all_one) {
    summarise_deprecate_variable_size()
  }

  if (!is_tibble(.data)) {
    # The `by` group data we build from is always a tibble,
    # so we have to manually downcast as needed
    out <- as.data.frame(out)
  }

  if (identical(.groups, "rowwise")) {
    out <- rowwise_df(out, character())
  }

  out
}

duckplyr_summarise <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- summarise(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
symdiff.data.frame <- function(x, y, ...) {
  # Our implementation
  check_dots_empty()

  x_names <- names(x)
  y_names <- names(y)
  if (identical(x_names, y_names)) {
    # Ensure identical() is very cheap
    y_names <- x_names
  }

  rel_try(
    "No duplicate names" = !identical(x_names, y_names) && anyDuplicated(x_names) && anyDuplicated(y_names),
    "Tables of different width" = length(x_names) != length(y_names),
    "Name mismatch" = !identical(x_names, y_names) && !all(y_names %in% x_names),
    {
      x_rel <- duckdb_rel_from_df(x)
      y_rel <- duckdb_rel_from_df(y)
      if (!identical(x_names, y_names)) {
        # FIXME: Select by position
        exprs <- nexprs_from_loc(x_names, set_names(seq_along(x_names), x_names))
        y_rel <- rel_project(y_rel, exprs)
      }

      rel <- rel_set_symdiff(x_rel, y_rel)
      out <- rel_to_df(rel)
      out <- dplyr_reconstruct(out, x)
      return(out)
    }
  )

  # dplyr forward
  symdiff <- symdiff_data_frame
  out <- symdiff(x, y, ...)
  return(out)

  # dplyr implementation
  check_dots_empty()
  check_compatible(x, y)

  out <- vec_set_symmetric_difference(x, y, error_call = current_env())

  dplyr_reconstruct(out, x)
}

duckplyr_symdiff <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- symdiff(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
duckplyr_tally <- function(x, ...) {
  try_fetch(
    x <- as_duckplyr_df(x),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- tally(x, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
transmute.data.frame <- function(.data, ...) {
  force(.data)

  dots <- check_transmute_args(...)
  dots <- dplyr_quosures(!!!dots)
  dots <- fix_auto_name(dots)

  rel_try(
    "Can't use relational with zero-column result set." = (length(dots) == 0),
    {
      exprs <- rel_translate_dots(dots, .data)
      rel <- duckdb_rel_from_df(.data)
      out_rel <- rel_project(rel, exprs)
      out <- rel_to_df(out_rel)
      out <- dplyr_reconstruct(out, .data)
      return(out)
    }
  )

  # dplyr forward
  transmute <- transmute_data_frame
  out <- transmute(.data, ...)
  return(out)

  # dplyr implementation
  dots <- check_transmute_args(...)
  dots <- dplyr_quosures(!!!dots)

  # We don't expose `.by` because `transmute()` is superseded
  by <- compute_by(by = NULL, data = .data)

  cols <- mutate_cols(.data, dots, by)

  out <- dplyr_col_modify(.data, cols)

  # Compact out `NULL` columns that got removed.
  # These won't exist in `out`, but we don't want them to look "new".
  # Note that `dplyr_col_modify()` makes it impossible to `NULL` a group column,
  # which we rely on below.
  cols <- compact_null(cols)

  # Retain expression columns in order of their appearance
  cols_expr <- names(cols)

  # Retain untouched group variables up front
  cols_group <- by$names
  cols_group <- setdiff(cols_group, cols_expr)

  cols_retain <- c(cols_group, cols_expr)

  dplyr_col_select(out, cols_retain)
}

duckplyr_transmute <- function(.data, ...) {
  try_fetch(
    .data <- as_duckplyr_df(.data),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- transmute(.data, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
ungroup.data.frame <- function(x, ...) {
  # Our implementation
  rel_try(
    "No relational implementation for ungroup()" = TRUE,
    {
      return(out)
    }
  )

  # dplyr forward
  ungroup <- ungroup_data_frame
  out <- ungroup(x, ...)
  return(out)

  # dplyr implementation
  check_dots_empty()
  x
}

duckplyr_ungroup <- function(x, ...) {
  try_fetch(
    x <- as_duckplyr_df(x),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- ungroup(x, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
union.data.frame <- function(x, y, ...) {
  # Our implementation
  check_dots_empty()

  # This is difficult to do manually due to order preservation
  return(distinct(union_all(x, y)))

  # dplyr forward
  union <- union_data_frame
  out <- union(x, y, ...)
  return(out)

  # dplyr implementation
  check_dots_empty()
  check_compatible(x, y)

  out <- vec_set_union(x, y, error_call = current_env())

  dplyr_reconstruct(out, x)
}

duckplyr_union <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- union(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

# Generated by 02-duckplyr_df-methods.R
#' @export
union_all.data.frame <- function(x, y, ...) {
  # Our implementation
  check_dots_empty()

  x_names <- names(x)
  y_names <- names(y)
  if (identical(x_names, y_names)) {
    # Ensure identical() is very cheap
    y_names <- x_names
  }

  rel_try(
    "No duplicate names" = !identical(x_names, y_names) && anyDuplicated(x_names) && anyDuplicated(y_names),
    "Tables of different width" = length(x_names) != length(y_names),
    "Name mismatch" = !identical(x_names, y_names) && !all(y_names %in% x_names),
    {
      x_rel <- duckdb_rel_from_df(x)
      y_rel <- duckdb_rel_from_df(y)
      if (!identical(x_names, y_names)) {
        # FIXME: Select by position
        exprs <- nexprs_from_loc(x_names, set_names(seq_along(x_names), x_names))
        y_rel <- rel_project(y_rel, exprs)
      }

      rel <- rel_union_all(x_rel, y_rel)
      out <- rel_to_df(rel)
      out <- dplyr_reconstruct(out, x)
      return(out)
    }
  )

  # dplyr forward
  union_all <- union_all_data_frame
  out <- union_all(x, y, ...)
  return(out)

  # dplyr implementation
  check_dots_empty()
  check_compatible(x, y)

  out <- vec_rbind(x, y)
  dplyr_reconstruct(out, x)
}

duckplyr_union_all <- function(x, y, ...) {
  try_fetch(
    {
      x <- as_duckplyr_df(x)
      y <- as_duckplyr_df(y)
    },
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- union_all(x, y, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}

